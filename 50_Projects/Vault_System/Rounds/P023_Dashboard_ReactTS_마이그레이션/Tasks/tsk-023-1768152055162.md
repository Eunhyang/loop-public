---
entity_type: Task
entity_id: tsk-023-1768152055162
entity_name: Dashboard - Notes 편집 시 커서 점프 버그 수정
created: '2026-01-12'
updated: '2026-01-12'
status: doing
project_id: prj-023
parent_id: prj-023
assignee: 김은향
priority: medium
start_date: '2026-01-12'
due: '2026-01-12'
aliases:
- tsk-023-1768152055162
tags: []
type: dev
---

# Dashboard - Notes 편집 시 커서 점프 버그 수정

## PRD (from Plan Mode)

### 문제
- Task Drawer에서 notes 작성 시 커서가 갑자기 맨 아래로 이동
- 버벅거림 현상 동반
- 주기적으로 발생

### 원인
1. notes 입력 → 300ms debounce → API 저장
2. API 성공 → `invalidateQueries(task(id))` → task refetch
3. 서버 응답으로 MarkdownEditor value 업데이트
4. `editor.commands.setContent(value)` 호출 → 커서가 끝으로 리셋

### 해결 방안
**편집 중(focus)일 때는 외부 value 변경을 무시**

### 수정 파일
`dashboard-v2/src/components/MarkdownEditor/MarkdownEditor.tsx`

### 변경 내용

#### 1. focus 상태 추적 ref 추가
```typescript
const isFocused = useRef(false)
```

#### 2. useEditor에서 focus/blur 이벤트 처리
```typescript
onFocus: () => {
  isFocused.current = true
},
onBlur: () => {
  isFocused.current = false
  // 기존 blur 로직...
},
```

#### 3. 외부 value 동기화 useEffect에서 focus 체크
```typescript
useEffect(() => {
  if (!editor) return
  if (isInitialMount.current) { ... }

  // 편집 중이면 외부 value 무시 (노션 방식)
  if (isFocused.current) return

  if (value === lastValue.current) return
  // ... 나머지 로직
}, [value, editor])
```

---

---

## Revision History

### Revision 1 (2026-01-12) - Text Loss Bug

**Issue**: pendingExternalValue 로직이 새로운 텍스트 손실 버그를 일으킴

**Problem Description**:
- Notes 편집 시 작성 중인 내용이 갑자기 사라짐
- 예시: "A는 B와 싸운다" 입력 → "싸운다"가 사라지고 "A는 B와"만 남음

**Root Cause Analysis**:
1. 사용자: "A는 B와" 입력 → API 저장 (debounced)
2. 서버 응답 → `pendingExternalValue = "A는 B와"` 저장됨
3. 사용자: "싸운다" 추가 (에디터 상태: "A는 B와 싸운다")
4. blur 발생:
   - `flush("A는 B와 싸운다")` → 비동기 실행 (서버 전송)
   - `pendingExternalValue("A는 B와")` → 동기 적용 (즉시 에디터 덮어쓰기)
   - 결과: "싸운다" 손실

**Race Condition**:
```
Timeline:
  T1: 사용자 "A는 B와" 입력
  T2: debounce timer fires → API 저장
  T3: API 응답 → pendingExternalValue = "A는 B와"
  T4: 사용자 "싸운다" 추가
  T5: blur → flush(비동기) + pendingExternalValue(동기)
  T6: pendingExternalValue가 먼저 적용 → 최신 입력 손실!
```

**Fix Direction**:
- pendingExternalValue 로직 **완전 제거**
- focus 중에는 외부 value 변경 **완전 무시**
- blur 시에는 flush만 수행 (진정한 Notion-style)
- 결론: 더 단순한 접근 = 더 안전한 접근

---

## Additional Requirements (Revision 1)

### 변경 목표
1. **pendingExternalValue ref 완전 제거**
2. **onBlur에서 pending 적용 로직 제거** - flush만 수행
3. **외부 value sync useEffect에서 단순화** - focused면 그냥 return

### 수정 전 코드 (문제 있음)
```typescript
// refs
const pendingExternalValue = useRef<string | null>(null)

// onBlur
onBlur: () => {
  isFocused.current = false
  debouncedOnChange.flush()
  // 문제: pendingExternalValue가 flush보다 먼저 동기 적용됨
  if (pendingExternalValue.current !== null && editor) {
    isProgrammaticUpdate.current = true
    editor.commands.setContent(pendingExternalValue.current)
    // ...
  }
}

// useEffect
if (isFocused.current) {
  pendingExternalValue.current = value  // 문제: 저장해둠
  return
}
```

### 수정 후 코드 (Notion-style)
```typescript
// refs - pendingExternalValue 제거!
// const pendingExternalValue = useRef<string | null>(null) // 삭제

// onBlur - 단순화
onBlur: () => {
  isFocused.current = false
  if (!readOnly) {
    debouncedOnChange.flush()  // flush만 수행
    onBlur?.()
  }
}

// useEffect - 단순화
if (isFocused.current) {
  return  // 편집 중이면 그냥 무시 (저장하지 않음)
}
```

### 왜 이게 더 안전한가?
1. **No race condition**: pending 값 자체가 없으므로 충돌 불가
2. **Simpler mental model**: focus = 로컬 권위, blur = 서버와 sync
3. **Notion 방식**: 사용자 입력 우선, 서버 값은 다음 focus 시 자연스럽게 반영

### Edge Case 처리
| Case | 처리 방식 |
|------|----------|
| Focus 중 서버 값 변경 | 무시 (사용자 입력 우선) |
| Blur 후 서버 값과 차이 | flush로 최신 상태 저장됨 |
| 다음 Focus 시 | 서버 최신 값으로 시작 (refetch 결과) |
| ReadOnly 상태 | 외부 값 즉시 적용 (기존 로직 유지) |

---

## 체크리스트 (Revision 1)

### 이전 완료 항목
- [x] MarkdownEditor에 isFocused ref 추가
- [x] useEditor에 onFocus/onBlur 핸들러 추가
- [x] useEffect에서 focus 상태 체크 추가
- [x] Codex plan validation (3 iterations)
- [x] Implementation with all edge cases
- [x] Codex code review (3 iterations, no blocking issues)
- [x] Build verification (TypeScript compilation passed)

### Revision 1 신규 항목
- [ ] pendingExternalValue ref 제거
- [ ] onBlur에서 pending 적용 로직 제거
- [ ] useEffect에서 pending 저장 로직 제거
- [ ] Build verification
- [ ] 로컬 테스트: 텍스트 손실 버그 수정 확인
- [ ] 로컬 테스트: 커서 점프 여전히 방지되는지 확인

## 검증 방법

### 기존 테스트 (커서 점프)
1. Dashboard 로컬 실행: `cd public/dashboard-v2 && pnpm dev`
2. Task Drawer 열기
3. Notes 영역에서 긴 문장 타이핑
4. 커서가 중간에 점프하지 않는지 확인
5. blur 후 다시 focus → 서버 값과 동기화되는지 확인

### Revision 1 테스트 (텍스트 손실)
1. Task Drawer의 Notes에서 문장 작성: "A는 B와"
2. 잠시 대기 (debounce 완료, API 저장됨)
3. 이어서 추가 입력: " 싸운다"
4. 즉시 blur (다른 영역 클릭)
5. **확인**: "A는 B와 싸운다" 전체가 보존되어야 함 (손실 없음)
6. 다시 focus → 저장된 값 확인

## 참고

---

## 작업 로그

### 2026-01-12 (Implementation Complete)

**개요**: MarkdownEditor 커서 점프 버그 수정 완료 (Codex-Claude Loop 적용)

**문제 분석**:
- 사용자 타이핑 → 300ms debounce → API 저장
- API 성공 → invalidateQueries → task refetch
- 서버 응답으로 value prop 업데이트
- useEffect가 editor.commands.setContent() 호출
- setContent()가 커서를 끝으로 리셋

**해결 방안 (Notion-style)**:
- 편집 중(focus)일 때는 외부 value 변경을 pending으로 저장
- blur 시에만 pending 값 적용
- 여러 edge case 처리 (Codex 피드백 기반)

**구현 내용**:

1. **Phase 1: Planning**
   - 문제 원인 분석 완료
   - 초기 구현 계획 수립

2. **Phase 2: Codex Plan Validation** (3 iterations)
   - Iteration 1: 외부 업데이트 누락 문제 발견
   - Iteration 2: Flush 순서 문제 및 stuck flag 문제 발견
   - Iteration 3: 개선된 계획 검증 완료

3. **Phase 3: Implementation**
   - isFocused ref 추가 (focus 상태 추적)
   - pendingExternalValue ref 추가 (focus 중 외부 업데이트 저장)
   - onFocus handler 추가
   - onBlur handler 구현:
     * flush BEFORE applying pending (stale overwrite 방지)
     * content diff check (stuck flag 방지)
     * readOnly 상태에서도 pending 적용 (sync 보장)
   - onUpdate handler 수정:
     * isProgrammaticUpdate 체크를 readOnly 체크보다 먼저 (stuck flag 방지)
   - External value sync useEffect 수정:
     * focused 상태면 pending에 저장
     * 아니면 즉시 적용

4. **Phase 4: Codex Code Review** (3 iterations)
   - Review 1: readOnly toggle 시 pending 미적용 문제 발견
   - Review 2: readOnly 모드에서 isProgrammaticUpdate stuck 문제 발견
   - Review 3: **No blocking issues - Production ready**

**Edge Cases 처리**:
✅ 타이핑 중 커서 점프 (main issue)
✅ Focus 중 외부 업데이트 누락 방지
✅ Flush로 인한 stale overwrite 방지
✅ Stuck isProgrammaticUpdate flag 방지
✅ ReadOnly toggle during focus 처리
✅ ReadOnly 모드에서 flag stuck 방지

**수정 파일**:
- `dashboard-v2/src/components/MarkdownEditor/MarkdownEditor.tsx`

**변경 사항**:
```typescript
// 1. 새로운 refs 추가 (line 44-45)
const isFocused = useRef(false)
const pendingExternalValue = useRef<string | null>(null)

// 2. onUpdate - isProgrammaticUpdate 체크 우선 (line 127-143)
onUpdate: ({ editor }) => {
  // CRITICAL: Check BEFORE readOnly to avoid stuck flag
  if (isProgrammaticUpdate.current) {
    isProgrammaticUpdate.current = false
    return
  }
  if (readOnly) return
  const markdown = getMarkdownFromEditor(editor)
  debouncedOnChange(markdown)
}

// 3. onFocus handler 추가 (line 144-146)
onFocus: () => {
  isFocused.current = true
}

// 4. onBlur handler 개선 (line 147-175)
onBlur: () => {
  isFocused.current = false

  // Flush BEFORE pending apply
  if (!readOnly) {
    debouncedOnChange.flush()
  }

  // Apply pending (ALWAYS, even in readOnly)
  if (pendingExternalValue.current !== null && editor) {
    const currentMarkdown = getMarkdownFromEditor(editor)
    if (pendingExternalValue.current !== currentMarkdown) {
      isProgrammaticUpdate.current = true
      editor.commands.setContent(pendingExternalValue.current)
      lastValue.current = pendingExternalValue.current
    }
    pendingExternalValue.current = null
  }

  if (!readOnly) {
    onBlur?.()
  }
}

// 5. External value sync useEffect (line 191-195)
if (isFocused.current) {
  pendingExternalValue.current = value
  return
}
```

**Codex Review 결과**:
- **Iteration 1**: "External updates missed if readOnly becomes true during focus"
  - 수정: pending apply를 readOnly guard 밖으로 이동
- **Iteration 2**: "isProgrammaticUpdate can remain stuck if setContent in readOnly"
  - 수정: onUpdate에서 flag 체크를 readOnly 체크보다 먼저
- **Iteration 3**: "No blocking issues found"
  - Residual risks: readOnly toggle 테스트, 빈번한 외부 업데이트 테스트 권장

**빌드 검증**:
```bash
cd dashboard-v2 && pnpm build
✓ TypeScript compilation successful
✓ Vite build complete (2.63s)
✓ No errors
```

**최종 상태**: Implementation Complete
- ✅ 모든 edge case 처리 완료
- ✅ Codex code review 통과 (no blocking issues)
- ✅ Build 성공
- ⏳ 로컬 테스트 대기 (사용자 검증 필요)

**Testing Suggestions** (Codex 권장):
1. readOnly toggle during focus with queued external updates
2. Typing while receiving frequent external updates (cursor stability)

**남은 작업**:
- [ ] 로컬 Dashboard 실행 및 수동 테스트
- [ ] 커서 점프 문제 해결 확인
- [ ] Task status → done

---

### 2026-01-12 (Revision 1 Implementation Complete)

**개요**: Text loss bug 수정 완료 - pendingExternalValue 로직 완전 제거

**문제 요약**:
- 이전 구현의 `pendingExternalValue` 로직이 새로운 텍스트 손실 버그 유발
- Race condition: flush(비동기) vs pendingExternalValue(동기) → 최신 입력 손실

**구현 내용** (Revision 1):

1. **pendingExternalValue ref 제거** (line 45)
   ```typescript
   // 삭제: const pendingExternalValue = useRef<string | null>(null)
   ```

2. **onBlur handler 단순화** (lines 146-154)
   ```typescript
   onBlur: () => {
     isFocused.current = false

     // Flush any pending debounced changes (Notion-style: sync on blur)
     if (!readOnly) {
       debouncedOnChange.flush()
       onBlur?.()
     }
   }
   ```
   - 기존: flush → pending 적용 (race condition 발생)
   - 변경: flush만 수행 (단순하고 안전)

3. **External value sync useEffect 단순화** (lines 176-180)
   ```typescript
   // If focused, ignore external value changes (Notion-style)
   // User input takes priority, server value will sync naturally on next focus
   if (isFocused.current) {
     return  // 저장하지 않고 그냥 무시
   }
   ```
   - 기존: pending에 저장
   - 변경: 완전히 무시 (진정한 Notion 방식)

**수정 파일**:
- `/dashboard-v2/src/components/MarkdownEditor/MarkdownEditor.tsx`

**변경 통계**:
- 삭제: 1 ref, ~20 lines (pending 관리 로직)
- 추가: 0 lines (단순화)
- 순 감소: ~21 lines

**빌드 검증**:
```bash
cd dashboard-v2 && pnpm build
✓ TypeScript compilation successful
✓ Vite build complete (2.94s)
✓ No errors
✓ dist/index-CqVydf7F.js: 278.19 kB (gzip: 81.62 kB)
```

**해결된 문제**:
✅ Text loss bug (main issue of Revision 1)
✅ Race condition between flush and pending apply
✅ Simpler mental model (no pending state to manage)
✅ Cursor jump still prevented (original issue remains fixed)

**Edge Cases 처리** (Notion-style):
| Case | 처리 방식 | 결과 |
|------|----------|------|
| Focus 중 서버 값 변경 | 완전히 무시 | 사용자 입력 우선 ✅ |
| Blur 후 서버 값과 차이 | flush로 최신 상태 저장 | 서버 sync ✅ |
| 다음 Focus 시 | 서버 최신 값으로 시작 | 자연스러운 동기화 ✅ |
| ReadOnly 상태 | 외부 값 즉시 적용 | 기존 로직 유지 ✅ |

**최종 상태**: Revision 1 Implementation Complete
- ✅ pendingExternalValue 완전 제거
- ✅ onBlur 단순화 (flush만 수행)
- ✅ useEffect 단순화 (focused면 그냥 return)
- ✅ Build 성공
- ⏳ 로컬 테스트 대기 (텍스트 손실 수정 확인)

**테스트 권장 사항**:
1. **텍스트 손실 테스트** (Revision 1 main issue):
   - Notes에서 "A는 B와" 입력 → 대기 (API 저장)
   - 이어서 " 싸운다" 입력 → 즉시 blur
   - 확인: "A는 B와 싸운다" 전체 보존 (손실 없음)

2. **커서 점프 테스트** (Original issue):
   - Notes에서 긴 문장 타이핑
   - 확인: 커서가 중간에 점프하지 않음

**코드 품질**:
- ✅ No race conditions (pending 제거로 원천 차단)
- ✅ Simpler code (21 lines 감소)
- ✅ Better maintainability (fewer states to manage)
- ✅ TypeScript type safety maintained

**구현 완료**: Ready for user testing and `/done-dev-task`
