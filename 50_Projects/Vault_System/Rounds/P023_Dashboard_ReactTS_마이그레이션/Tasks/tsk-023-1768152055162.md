---
entity_type: Task
entity_id: tsk-023-1768152055162
entity_name: Dashboard - Notes 편집 시 커서 점프 버그 수정
created: '2026-01-12'
updated: '2026-01-12'
status: todo
project_id: prj-023
parent_id: prj-023
assignee: 김은향
priority: medium
start_date: '2026-01-12'
due: '2026-01-12'
aliases:
- tsk-023-1768152055162
tags: []
type: dev
---

# Dashboard - Notes 편집 시 커서 점프 버그 수정

## PRD (from Plan Mode)

### 문제
- Task Drawer에서 notes 작성 시 커서가 갑자기 맨 아래로 이동
- 버벅거림 현상 동반
- 주기적으로 발생

### 원인
1. notes 입력 → 300ms debounce → API 저장
2. API 성공 → `invalidateQueries(task(id))` → task refetch
3. 서버 응답으로 MarkdownEditor value 업데이트
4. `editor.commands.setContent(value)` 호출 → 커서가 끝으로 리셋

### 해결 방안
**편집 중(focus)일 때는 외부 value 변경을 무시**

### 수정 파일
`dashboard-v2/src/components/MarkdownEditor/MarkdownEditor.tsx`

### 변경 내용

#### 1. focus 상태 추적 ref 추가
```typescript
const isFocused = useRef(false)
```

#### 2. useEditor에서 focus/blur 이벤트 처리
```typescript
onFocus: () => {
  isFocused.current = true
},
onBlur: () => {
  isFocused.current = false
  // 기존 blur 로직...
},
```

#### 3. 외부 value 동기화 useEffect에서 focus 체크
```typescript
useEffect(() => {
  if (!editor) return
  if (isInitialMount.current) { ... }

  // 편집 중이면 외부 value 무시 (노션 방식)
  if (isFocused.current) return

  if (value === lastValue.current) return
  // ... 나머지 로직
}, [value, editor])
```

---

## 체크리스트

- [x] MarkdownEditor에 isFocused ref 추가
- [x] useEditor에 onFocus/onBlur 핸들러 추가
- [x] useEffect에서 focus 상태 체크 추가
- [x] Codex plan validation (3 iterations)
- [x] Implementation with all edge cases
- [x] Codex code review (3 iterations, no blocking issues)
- [x] Build verification (TypeScript compilation passed)
- [ ] 로컬 테스트 (pnpm dev)
- [ ] 커서 점프 문제 해결 확인

## 검증 방법
1. Dashboard 로컬 실행: `cd public/dashboard-v2 && pnpm dev`
2. Task Drawer 열기
3. Notes 영역에서 긴 문장 타이핑
4. 커서가 중간에 점프하지 않는지 확인
5. blur 후 다시 focus → 서버 값과 동기화되는지 확인

## 참고

---

## 작업 로그

### 2026-01-12 (Implementation Complete)

**개요**: MarkdownEditor 커서 점프 버그 수정 완료 (Codex-Claude Loop 적용)

**문제 분석**:
- 사용자 타이핑 → 300ms debounce → API 저장
- API 성공 → invalidateQueries → task refetch
- 서버 응답으로 value prop 업데이트
- useEffect가 editor.commands.setContent() 호출
- setContent()가 커서를 끝으로 리셋

**해결 방안 (Notion-style)**:
- 편집 중(focus)일 때는 외부 value 변경을 pending으로 저장
- blur 시에만 pending 값 적용
- 여러 edge case 처리 (Codex 피드백 기반)

**구현 내용**:

1. **Phase 1: Planning**
   - 문제 원인 분석 완료
   - 초기 구현 계획 수립

2. **Phase 2: Codex Plan Validation** (3 iterations)
   - Iteration 1: 외부 업데이트 누락 문제 발견
   - Iteration 2: Flush 순서 문제 및 stuck flag 문제 발견
   - Iteration 3: 개선된 계획 검증 완료

3. **Phase 3: Implementation**
   - isFocused ref 추가 (focus 상태 추적)
   - pendingExternalValue ref 추가 (focus 중 외부 업데이트 저장)
   - onFocus handler 추가
   - onBlur handler 구현:
     * flush BEFORE applying pending (stale overwrite 방지)
     * content diff check (stuck flag 방지)
     * readOnly 상태에서도 pending 적용 (sync 보장)
   - onUpdate handler 수정:
     * isProgrammaticUpdate 체크를 readOnly 체크보다 먼저 (stuck flag 방지)
   - External value sync useEffect 수정:
     * focused 상태면 pending에 저장
     * 아니면 즉시 적용

4. **Phase 4: Codex Code Review** (3 iterations)
   - Review 1: readOnly toggle 시 pending 미적용 문제 발견
   - Review 2: readOnly 모드에서 isProgrammaticUpdate stuck 문제 발견
   - Review 3: **No blocking issues - Production ready**

**Edge Cases 처리**:
✅ 타이핑 중 커서 점프 (main issue)
✅ Focus 중 외부 업데이트 누락 방지
✅ Flush로 인한 stale overwrite 방지
✅ Stuck isProgrammaticUpdate flag 방지
✅ ReadOnly toggle during focus 처리
✅ ReadOnly 모드에서 flag stuck 방지

**수정 파일**:
- `dashboard-v2/src/components/MarkdownEditor/MarkdownEditor.tsx`

**변경 사항**:
```typescript
// 1. 새로운 refs 추가 (line 44-45)
const isFocused = useRef(false)
const pendingExternalValue = useRef<string | null>(null)

// 2. onUpdate - isProgrammaticUpdate 체크 우선 (line 127-143)
onUpdate: ({ editor }) => {
  // CRITICAL: Check BEFORE readOnly to avoid stuck flag
  if (isProgrammaticUpdate.current) {
    isProgrammaticUpdate.current = false
    return
  }
  if (readOnly) return
  const markdown = getMarkdownFromEditor(editor)
  debouncedOnChange(markdown)
}

// 3. onFocus handler 추가 (line 144-146)
onFocus: () => {
  isFocused.current = true
}

// 4. onBlur handler 개선 (line 147-175)
onBlur: () => {
  isFocused.current = false

  // Flush BEFORE pending apply
  if (!readOnly) {
    debouncedOnChange.flush()
  }

  // Apply pending (ALWAYS, even in readOnly)
  if (pendingExternalValue.current !== null && editor) {
    const currentMarkdown = getMarkdownFromEditor(editor)
    if (pendingExternalValue.current !== currentMarkdown) {
      isProgrammaticUpdate.current = true
      editor.commands.setContent(pendingExternalValue.current)
      lastValue.current = pendingExternalValue.current
    }
    pendingExternalValue.current = null
  }

  if (!readOnly) {
    onBlur?.()
  }
}

// 5. External value sync useEffect (line 191-195)
if (isFocused.current) {
  pendingExternalValue.current = value
  return
}
```

**Codex Review 결과**:
- **Iteration 1**: "External updates missed if readOnly becomes true during focus"
  - 수정: pending apply를 readOnly guard 밖으로 이동
- **Iteration 2**: "isProgrammaticUpdate can remain stuck if setContent in readOnly"
  - 수정: onUpdate에서 flag 체크를 readOnly 체크보다 먼저
- **Iteration 3**: "No blocking issues found"
  - Residual risks: readOnly toggle 테스트, 빈번한 외부 업데이트 테스트 권장

**빌드 검증**:
```bash
cd dashboard-v2 && pnpm build
✓ TypeScript compilation successful
✓ Vite build complete (2.63s)
✓ No errors
```

**최종 상태**: Implementation Complete
- ✅ 모든 edge case 처리 완료
- ✅ Codex code review 통과 (no blocking issues)
- ✅ Build 성공
- ⏳ 로컬 테스트 대기 (사용자 검증 필요)

**Testing Suggestions** (Codex 권장):
1. readOnly toggle during focus with queued external updates
2. Typing while receiving frequent external updates (cursor stability)

**남은 작업**:
- [ ] 로컬 Dashboard 실행 및 수동 테스트
- [ ] 커서 점프 문제 해결 확인
- [ ] Task status → done
