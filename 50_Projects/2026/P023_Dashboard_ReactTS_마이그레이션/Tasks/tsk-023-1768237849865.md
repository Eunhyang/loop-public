---
entity_type: Task
entity_id: tsk-bpnbz2-1768237849865
entity_name: Dashboard - Task Drawer Duplicate Loading 버그 수정
created: '2026-01-13'
updated: '2026-01-13'
status: done
closed: '2026-01-13'
project_id: prj-023
parent_id: prj-023
assignee: 김은향
priority: medium
start_date: '2026-01-13'
due: '2026-01-13'
aliases:
- tsk-023-1768237849865
- tsk-bpnbz2-1768237849865
tags: []
type: dev
target_project: loop
---

# Dashboard - Task Drawer Duplicate Loading 버그 수정

## 설명

Task drawer에서 Duplicate 버튼 클릭 시 "Loading..." 무한 표시 버그를 수정합니다. 복제는 성공하지만 새 task 데이터가 React Query 캐시에 즉시 저장되지 않아 발생하는 레이스 컨디션을 해결합니다.

## 체크리스트

- [ ] api.ts - duplicateTask 타입 정의 수정 (TaskResponse 스키마와 일치)
- [ ] queries.ts - useDuplicateTask onSuccess에서 proactive caching 추가
- [ ] EntityDrawer.tsx - new_task_id → task_id 필드명 수정
- [ ] 기능 테스트: 복제 후 즉시 drawer 열림 확인 (< 500ms)
- [ ] React Query DevTools로 캐시 상태 검증
- [ ] 엣지 케이스 테스트 (연속 복제, 느린 네트워크)
- [ ] 회귀 테스트 (create/update/delete 정상 동작 확인)
- [ ] npm run build 통과

## 참고

Plan 파일: `/Users/gim-eunhyang/.claude/plans/tingly-bouncing-wozniak.md` (HIGH-LEVEL 참고용)

## Notes

### Tech Spec

**Architecture Compliance:**
- Parent Project: prj-023 (Dashboard - React+TS 마이그레이션)
- Architecture Pattern: Clean Architecture + SSOT + Feature-based modularity (Section 1)
- Layer Separation: API Layer → Query Layer → UI Layer (Section 0.2, 0.3)
- SSOT Principle: React Query cache as single source of truth (Section 0.3)

**File Structure:** (CODEX FEEDBACK #3: 정확한 경로로 수정)
```
dashboard-v2/src/
├── features/tasks/
│   ├── api.ts                    # 수정 (line 32-33): duplicateTask 타입 정의
│   └── queries.ts                # 수정 (line 130-141): useDuplicateTask proactive caching
└── components/layout/
    └── EntityDrawer.tsx          # 수정 (line 99): new_task_id → task_id

# 실제 절대 경로:
# - ~/dev/loop/public/dashboard-v2/src/features/tasks/api.ts
# - ~/dev/loop/public/dashboard-v2/src/features/tasks/queries.ts
# - ~/dev/loop/public/dashboard-v2/src/components/layout/EntityDrawer.tsx
```

**Implementation Details:**

1. **API Layer 수정** (`api.ts:32-33`) - CODEX FEEDBACK #1 적용
   - Current type: `{ new_task_id: string; source_task_id: string }`
   - Backend actual: `{ success: boolean; task_id: string; file_path: string; message: string; task?: Task; validation?: ValidationResult }`
   - Fix: Match backend `TaskResponse` schema (api/models/entities.py:138-145)
   - Add `task?: Task` field (optional) and `validation?: ValidationResult` field
   - Handle validation failure case (task 없을 수 있음)

2. **Query Layer 수정** (`queries.ts:130-141`) - CODEX FEEDBACK #2, #4 적용
   - Pattern: Follow `useUpdateTask` (lines 22-74) and `useCreateTask` (lines 76-89) patterns
   - Current issue: Only `invalidateQueries()` → refetch → race condition
   - Fix: Proactive cache population with `setQueryData()`
   - Cache targets:
     - Individual cache: `queryKeys.task(newTaskId)` ← immediate render
     - Master cache: `queryKeys.dashboardInit` tasks array ← Kanban board update (CODEX #4: 다른 필드 보존)
   - Strategy: `setQueryData` before `invalidateQueries` (no rollback needed for create)
   - CODEX #2: `invalidateQueries({ queryKey: ['tasks'] })` prefix invalidation으로 필터 쿼리도 무효화
   - CODEX #4: dashboardInit 업데이트시 `(old) => ({ ...old, tasks: [...] })` 패턴으로 다른 필드 보존

3. **UI Layer 수정** (`EntityDrawer.tsx:99`)
   - Current field: `response.data.new_task_id`
   - Backend actual: `response.data.task_id`
   - Fix: Change field name to match backend TaskResponse schema
   - Impact: Enables immediate drawer open without "Loading..." state

**Data Models:**
```typescript
// Backend TaskResponse (SSOT) - CODEX FEEDBACK #1: validation 필드 추가
interface TaskResponse {
  success: boolean;
  task_id: string;          // ← NOT new_task_id
  file_path: string;
  message: string;
  task?: Task;              // ← CODEX: task는 optional (validation 실패시 없음)
  validation?: ValidationResult; // ← CODEX: 백엔드 실제 응답 필드 추가
}

// ValidationResult (백엔드 실제 타입)
interface ValidationResult {
  valid: boolean;
  errors?: string[];
  warnings?: string[];
}

// Frontend Task (src/types/task.ts)
interface Task {
  entity_id: string;
  entity_name: string;
  project_id: string;
  assignee: string;
  status: 'todo' | 'doing' | 'hold' | 'done' | 'blocked';
  priority: 'critical' | 'high' | 'medium' | 'low';
  type: 'dev' | 'bug' | 'strategy' | 'research' | 'ops' | 'meeting' | null;
  // ... 28 total fields
}

// CODEX FEEDBACK #4: DashboardInitResponse 실제 타입 확장
interface DashboardInitResponse {
  tasks: Task[];
  projects: Project[];
  constants: Constants;      // ← CODEX: 실제 응답 필드
  members: Member[];         // ← CODEX: 실제 응답 필드
  programs: Program[];       // ← CODEX: 실제 응답 필드
  hypotheses: Hypothesis[];  // ← CODEX: 실제 응답 필드
  conditions: Condition[];   // ← CODEX: 실제 응답 필드
  pending_badge_count: number; // ← CODEX: 실제 응답 필드
  user: User;                // ← CODEX: 실제 응답 필드
}
```

**State Management:**
- React Query key structure (src/queries/keys.ts):
  - `['dashboard', 'init']` - Master cache (all tasks + projects + metadata)
  - `['tasks', taskId]` - Individual task cache
  - `['tasks', filters]` - Filtered task lists
- Cache update order:
  1. `setQueryData(['tasks', newTaskId], newTask)` ← Prevents "Loading..."
  2. `setQueryData(['dashboard', 'init'], (old) => ({ ...old, tasks: [...old.tasks, newTask] }))` ← CODEX #4: 다른 필드 보존 (constants, members, programs 등)
  3. `invalidateQueries({ queryKey: ['tasks'] })` ← CODEX #2: prefix invalidation으로 필터 포함 모든 tasks 쿼리 무효화

**Key Functions:**

1. `taskApi.duplicateTask(id: string)` (api.ts:32-33)
   - Parameters: `id` (source task ID)
   - Returns: `AxiosResponse<TaskResponse>`
   - HTTP: `POST /api/tasks/${id}/duplicate`
   - Backend: tasks.py:541-547 (already correct)

2. `useDuplicateTask()` (queries.ts:130-141) - CODEX FEEDBACK #2, #4 적용
   - Returns: `UseMutationResult<AxiosResponse<TaskResponse>, Error, string>`
   - onSuccess signature: `(response: AxiosResponse<TaskResponse>) => void`
   - Extract: `response.data.task_id`, `response.data.task` (optional - validation 체크 필요)
   - Update caches:
     - queryKeys.task(id) - individual cache
     - queryKeys.dashboardInit - CODEX #4: `(old) => ({ ...old, tasks: [...] })` 패턴으로 다른 필드 보존
   - Invalidate: CODEX #2: `{ queryKey: ['tasks'] }` prefix invalidation (필터 쿼리 포함)

3. `handleDuplicate()` (EntityDrawer.tsx:95-104)
   - Trigger: Duplicate button click (line 124)
   - Callback: `onSuccess(response)` → extract `task_id` → `openEntityDrawer()`
   - Dependencies: `duplicateTask` mutation, `openEntityDrawer` context function

**Dependencies:**
- No new packages required
- Existing: @tanstack/react-query, axios
- Pattern: Consistent with existing mutation patterns

**Edge Cases:**

1. **연속 복제 (Same task duplicated 3x rapidly)**
   - Situation: User clicks Duplicate → Duplicate → Duplicate without waiting
   - Handling: Each mutation has independent `onSuccess` → 3 separate cache entries
   - Test: Verify 3 new tasks in dashboardInit.tasks array
   - Expected: All 3 drawers open sequentially, no race condition

2. **느린 네트워크 (API takes 3+ seconds)**
   - Situation: Mobile/3G network, API response delayed
   - Handling: `onSuccess` only fires after API completes → cache populated atomically
   - Test: Chrome DevTools → Network → Slow 3G
   - Expected: Drawer opens immediately after API success, not before

3. **복제 중 drawer 닫기 (User closes drawer while mutation pending)**
   - Situation: Click Duplicate → Click Close before API returns
   - Handling: Mutation continues, onSuccess still fires → cache updated
   - Test: Rapid Duplicate + Close
   - Expected: New task appears in Kanban board, no UI error

4. **API 실패 (Backend returns 500 or 403)**
   - Situation: Disk full, permissions error, validation failure
   - Handling: `onSuccess` not called → cache unchanged → UI shows error toast
   - Test: Mock API failure with network intercept
   - Expected: Error message displayed, source drawer remains open

5. **대용량 task (Task has 50+ attachments, 10KB notes)**
   - Situation: Duplicate large task with many relationships
   - Handling: Backend returns full task → setQueryData stores ~15KB object
   - Test: Duplicate task with max attachments/links
   - Expected: < 100ms cache write time, no memory leak

6. **동시 사용자 (Another user modifies same task during duplicate)**
   - Situation: User A duplicates task X while User B edits task X
   - Handling: Backend creates new task Y (independent) → no conflict
   - Test: Two browser windows, simultaneous actions
   - Expected: Both operations succeed independently

7. **캐시 부재 (dashboardInit not loaded yet)**
   - Situation: Direct URL to task drawer → duplicate before dashboard loads
   - Handling: `getQueryData(queryKeys.dashboardInit)` returns `undefined` → skip update
   - Test: Navigate directly to `/kanban?taskId=tsk-001`
   - Expected: Individual task cache updated, Kanban updates on next page load

**Architecture Diagram:**
```
┌────────────────────────────────────────────────────────────┐
│                   Current Flow (버그)                       │
└────────────────────────────────────────────────────────────┘

User clicks Duplicate
    ↓
duplicateTask(id)
    ↓
Backend returns { task_id, task: {...} }
    ↓
onSuccess() → invalidate caches only
    ↓                     ↓
openDrawer(newId)     refetch starts (background)
    ↓                     ↓
useTask(newId)        ['dashboard', 'init'] fetching
    ↓                     ↓
Query cache lookup → MISS (cache empty)
    ↓
isLoading=true, task=null
    ↓
UI: "Loading..." ∞ (무한 대기)
    ↓
['dashboard', 'init'] refetch completes
    ↓
['tasks', newId] still empty! (not individually cached)
    ↓
∞ Loading continues

─────────────────────────────────────────────────────────────

┌────────────────────────────────────────────────────────────┐
│                   Fixed Flow (패치 후)                      │
└────────────────────────────────────────────────────────────┘

User clicks Duplicate
    ↓
duplicateTask(id)
    ↓
Backend returns { task_id, task: {...} }
    ↓
onSuccess(response)
    ├─→ newTask = response.data.task
    ├─→ newTaskId = response.data.task_id
    ├─→ setQueryData(['tasks', newTaskId], newTask)  ← CACHE HIT!
    ├─→ update dashboardInit.tasks array
    └─→ invalidate filtered lists
    ↓
openDrawer(newTaskId)
    ↓
useTask(newTaskId)
    ↓
Query cache lookup → HIT (data already in cache)
    ↓
isLoading=false, task={...} ✅
    ↓
UI: Instant render (< 500ms)
```

**Performance Impact:**
- Before: 2-3초 (API → refetch wait → render)
- After: < 500ms (API → immediate render)
- Improvement: ~80% faster perceived loading
- Memory: +2KB per duplicated task (negligible)
- Cache consistency: Guaranteed by setQueryData atomicity

**Testing Strategy:**

1. **Unit Tests** (manual - no test framework yet)
   - Test api.ts type with mock response
   - Test queries.ts cache updates with React Query DevTools
   - Test EntityDrawer.tsx handler with console.log

2. **Integration Tests**
   - Full duplicate flow: button → API → cache → drawer
   - Verify Kanban board updates immediately
   - Check React Query DevTools for cache state

3. **Regression Tests**
   - Existing useCreateTask behavior unchanged
   - Existing useUpdateTask behavior unchanged
   - Other mutations (delete, update status) work normally

4. **Edge Case Tests** (see Edge Cases section above)
   - Test all 7 scenarios manually
   - Document any failures in task notes

**Rollback Plan:**
- If bugs found: Revert 3 file changes (git revert)
- No database migration required (frontend-only change)
- No API version change required (backend already correct)

### Todo

- [ ] `~/dev/loop/public/dashboard-v2/src/features/tasks/api.ts` (line 32-33): **CODEX #1, #3** Update `duplicateTask` return type to match backend `TaskResponse` schema - add fields: `success: boolean`, `task_id: string` (not new_task_id), `file_path: string`, `message: string`, `task?: Task` (optional), `validation?: ValidationResult` (optional)
- [ ] `~/dev/loop/public/dashboard-v2/src/features/tasks/queries.ts` (line 130-141): **CODEX #2, #4** Rewrite `useDuplicateTask` onSuccess callback - extract `response.data.task` (optional 체크) and `response.data.task_id`, call `setQueryData(queryKeys.task(newTaskId), newTask)` for immediate cache, update `dashboardInit.tasks` array with `(old) => ({ ...old, tasks: [...old.tasks, newTask] })` pattern to preserve other fields, then invalidate filtered lists with `invalidateQueries({ queryKey: ['tasks'] })` prefix invalidation
- [ ] `~/dev/loop/public/dashboard-v2/src/components/layout/EntityDrawer.tsx` (line 99): **CODEX #3** Change `response.data.new_task_id` to `response.data.task_id` to match backend field name
- [ ] Verify fix: Open task drawer → click Duplicate → confirm new drawer opens instantly (< 500ms) without "Loading..." state
- [ ] Test edge case: Duplicate same task 3 times rapidly → verify all 3 new tasks appear in Kanban board
- [ ] Test edge case: Chrome DevTools Slow 3G → duplicate → verify drawer opens after API completes
- [ ] Test edge case: Click Duplicate then immediately Close → verify new task still appears in board
- [ ] React Query DevTools: Inspect cache after duplicate → confirm `['tasks', 'tsk-xxx']` and `['dashboard', 'init']` both updated
- [ ] Regression test: Create new task → verify normal behavior
- [ ] Regression test: Update existing task → verify optimistic update works
- [ ] Regression test: Delete task → verify removal from board
- [ ] Build verification: `npm run build` must pass with 0 errors
- [ ] Code review: Verify cache consistency pattern matches `useUpdateTask` (lines 22-74)
