---
entity_type: Task
entity_id: tsk-023-1768152055162
entity_name: Dashboard - Notes 편집 시 커서 점프 버그 수정
created: '2026-01-12'
updated: '2026-01-13'
status: done
project_id: prj-023
parent_id: prj-023
assignee: 김은향
priority: medium
start_date: '2026-01-12'
due: '2026-01-12'
aliases:
- tsk-023-1768152055162
tags: []
type: dev
notes: "# Dashboard - Notes 편집 시 커서 점프 버그 수정\n\n## PRD (from Plan Mode)\n\n### 문제\n\
  \n- Task Drawer에서 notes 작성 시 커서가 갑자기 맨 아래로 이동\n- 버벅거림 현상 동반\n- 주기적으로 발생\n\n### 원인\n\
  \n1. notes 입력 → 300ms debounce → API 저장\n2. API 성공 → `invalidateQueries(task(id))`\
  \ → task refetch\n3. 서버 응답으로 MarkdownEditor value 업데이트\n4. `editor.commands.setContent(value)`\
  \ 호출 → 커서가 끝으로 리셋\n\n### 해결 방안\n\n**편집 중(focus)일 때는 외부 value 변경을 무시**\n\n### 수정\
  \ 파일\n\n`dashboard-v2/src/components/MarkdownEditor/MarkdownEditor.tsx`\n\n### 변경\
  \ 내용\n\n1\\. focus 상태 추적 ref 추가\n\n```typescript\nconst isFocused = useRef(false)\n\
  ```\n\n2\\. useEditor에서 focus/blur 이벤트 처리\n\n```typescript\nonFocus: () => {\n \
  \ isFocused.current = true\n},\nonBlur: () => {\n  isFocused.current = false\n \
  \ // 기존 blur 로직...\n},\n```\n\n3\\. 외부 value 동기화 useEffect에서 focus 체크\n\n```typescript\n\
  useEffect(() => {\n  if (!editor) return\n  if (isInitialMount.current) { ... }\n\
  \n  // 편집 중이면 외부 value 무시 (노션 방식)\n  if (isFocused.current) return\n\n  if (value\
  \ === lastValue.current) return\n  // ... 나머지 로직\n}, [value, editor])\n```\n\n---\n\
  \n---\n\n## Revision History\n\n### Revision 1 (2026-01-12) - Text Loss Bug\n\n\
  **Issue**: pendingExternalValue 로직이 새로운 텍스트 손실 버그를 일으킴\n\n**Problem Description**:\n\
  \n- Notes 편집 시 작성 중인 내용이 갑자기 사라짐\n- 예시: \"A는 B와 싸운다\" 입력 → \"싸운다\"가 사라지고 \"A는 B와\"\
  만 남음\n\n**Root Cause Analysis**:\n\n1. 사용자: \"A는 B와\" 입력 → API 저장 (debounced)\n\
  2. 서버 응답 → `pendingExternalValue = \"A는 B와\"` 저장됨\n3. 사용자: \"싸운다\" 추가 (에디터 상태: \"\
  A는 B와 싸운다\")\n4. blur 발생:\n   - `flush(\"A는 B와 싸운다\")` → 비동기 실행 (서버 전송)\n   - `pendingExternalValue(\"\
  A는 B와\")` → 동기 적용 (즉시 에디터 덮어쓰기)\n   - 결과: \"싸운다\" 손실\n\n**Race Condition**:\n\n\
  ```\nTimeline:\n  T1: 사용자 \"A는 B와\" 입력\n  T2: debounce timer fires → API 저장\n  T3:\
  \ API 응답 → pendingExternalValue = \"A는 B와\"\n  T4: 사용자 \"싸운다\" 추가\n  T5: blur →\
  \ flush(비동기) + pendingExternalValue(동기)\n  T6: pendingExternalValue가 먼저 적용 → 최신\
  \ 입력 손실!\n```\n\n**Fix Direction**:\n\n- pendingExternalValue 로직 **완전 제거**\n- focus\
  \ 중에는 외부 value 변경 **완전 무시**\n- blur 시에는 flush만 수행 (진정한 Notion-style)\n- 결론: 더 단순한\
  \ 접근 = 더 안전한 접근\n\n---\n\n## Additional Requirements (Revision 1)\n\n### 변경 목표\n\
  \n1. **pendingExternalValue ref 완전 제거**\n2. **onBlur에서 pending 적용 로직 제거** - flush만\
  \ 수행\n3. **외부 value sync useEffect에서 단순화** - focused면 그냥 return\n\n### 수정 전 코드 (문제\
  \ 있음)\n\n```typescript\n// refs\nconst pendingExternalValue = useRef<string | null>(null)\n\
  \n// onBlur\nonBlur: () => {\n  isFocused.current = false\n  debouncedOnChange.flush()\n\
  \  // 문제: pendingExternalValue가 flush보다 먼저 동기 적용됨\n  if (pendingExternalValue.current\
  \ !== null && editor) {\n    isProgrammaticUpdate.current = true\n    editor.commands.setContent(pendingExternalValue.current)\n\
  \    // ...\n  }\n}\n\n// useEffect\nif (isFocused.current) {\n  pendingExternalValue.current\
  \ = value  // 문제: 저장해둠\n  return\n}\n```\n\n### 수정 후 코드 (Notion-style)\n\n```typescript\n\
  // refs - pendingExternalValue 제거!\n// const pendingExternalValue = useRef<string\
  \ | null>(null) // 삭제\n\n// onBlur - 단순화\nonBlur: () => {\n  isFocused.current =\
  \ false\n  if (!readOnly) {\n    debouncedOnChange.flush()  // flush만 수행\n    onBlur?.()\n\
  \  }\n}\n\n// useEffect - 단순화\nif (isFocused.current) {\n  return  // 편집 중이면 그냥\
  \ 무시 (저장하지 않음)\n}\n```\n\n### 왜 이게 더 안전한가?\n\n1. **No race condition**: pending\
  \ 값 자체가 없으므로 충돌 불가\n2. **Simpler mental model**: focus = 로컬 권위, blur = 서버와 sync\n\
  3. **Notion 방식**: 사용자 입력 우선, 서버 값은 다음 focus 시 자연스럽게 반영\n\n### Edge Case 처리\n\n|\
  \ Case | 처리 방식 |\n| --- | --- |\n| Focus 중 서버 값 변경 | 무시 (사용자 입력 우선) |\n| Blur 후\
  \ 서버 값과 차이 | flush로 최신 상태 저장됨 |\n| 다음 Focus 시 | 서버 최신 값으로 시작 (refetch 결과) |\n| ReadOnly\
  \ 상태 | 외부 값 즉시 적용 (기존 로직 유지) |\n\n---\n\n## 체크리스트 (Revision 1)\n\n### 이전 완료 항목\n\
  \n- [x] MarkdownEditor에 isFocused ref 추가\n\n- [x] useEditor에 onFocus/onBlur 핸들러\
  \ 추가\n\n- [x] useEffect에서 focus 상태 체크 추가\n\n- [x] Codex plan validation (3 iterations)\n\
  \n- [x] Implementation with all edge cases\n\n- [x] Codex code review (3 iterations,\
  \ no blocking issues)\n\n- [x] Build verification (TypeScript compilation passed)\n\
  \n### Revision 1 신규 항목\n\n- [ ] pendingExternalValue ref 제거\n\n- [ ] onBlur에서 pending\
  \ 적용 로직 제거\n\n- [ ] useEffect에서 pending 저장 로직 제거\n\n- [ ] Build verification\n\n\
  - [ ] 로컬 테스트: 텍스트 손실 버그 수정 확인\n\n- [ ] 로컬 테스트: 커서 점프 여전히 방지되는지 확인\n\n## 검증 방법\n\n\
  ### 기존 테스트 (커서 점프)\n\n1. Dashboard 로컬 실행: `cd public/dashboard-v2 && pnpm dev`\n\
  2. Task Drawer 열기\n3. Notes 영역에서 긴 문장 타이핑\n4. 커서가 중간에 점프하지 않는지 확인\n5. blur 후 다시\
  \ focus → 서버 값과 동기화되는지 확인\n\n### Revision 1 테스트 (텍스트 손실)\n\n1. Task Drawer의 Notes에서\
  \ 문장 작성: \"A는 B와\"\n2. 잠시 대기 (debounce 완료, API 저장됨)\n3. 이어서 추가 입력: \" 싸운다\"\n4.\
  \ 즉시 blur (다른 영역 클릭)\n5. **확인**: \"A는 B와 싸운다\" 전체가 보존되어야 함 (손실 없음)\n6. 다시 focus\
  \ → 저장된 값 확인\n\n## 참고\n\n---\n\n## 작업 로그\n\n### 2026-01-12 (Implementation Complete)\n\
  \n**개요**: MarkdownEditor 커서 점프 버그 수정 완료 (Codex-Claude Loop 적용)\n\n**문제 분석**:\n\n\
  - 사용자 타이핑 → 300ms debounce → API 저장\n- API 성공 → invalidateQueries → task refetch\n\
  - 서버 응답으로 value prop 업데이트\n- useEffect가 editor.commands.setContent() 호출\n- setContent()가\
  \ 커서를 끝으로 리셋\n\n**해결 방안 (Notion-style)**:\n\n- 편집 중(focus)일 때는 외부 value 변경을 pending으로\
  \ 저장\n- blur 시에만 pending 값 적용\n- 여러 edge case 처리 (Codex 피드백 기반)\n\n**구현 내용**:\n\n\
  1. **Phase 1: Planning**\n\n   - 문제 원인 분석 완료\n   - 초기 구현 계획 수립\n\n2. **Phase 2:\
  \ Codex Plan Validation** (3 iterations)\n\n   - Iteration 1: 외부 업데이트 누락 문제 발견\n\
  \   - Iteration 2: Flush 순서 문제 및 stuck flag 문제 발견\n   - Iteration 3: 개선된 계획 검증 완료\n\
  \n3. **Phase 3: Implementation**\n\n   - isFocused ref 추가 (focus 상태 추적)\n   - pendingExternalValue\
  \ ref 추가 (focus 중 외부 업데이트 저장)\n   - onFocus handler 추가\n   - onBlur handler 구현:\n\
  \     - flush BEFORE applying pending (stale overwrite 방지)\n     - content diff\
  \ check (stuck flag 방지)\n     - readOnly 상태에서도 pending 적용 (sync 보장)\n   - onUpdate\
  \ handler 수정:\n     - isProgrammaticUpdate 체크를 readOnly 체크보다 먼저 (stuck flag 방지)\n\
  \   - External value sync useEffect 수정:\n     - focused 상태면 pending에 저장\n     -\
  \ 아니면 즉시 적용\n\n4. **Phase 4: Codex Code Review** (3 iterations)\n\n   - Review 1:\
  \ readOnly toggle 시 pending 미적용 문제 발견\n   - Review 2: readOnly 모드에서 isProgrammaticUpdate\
  \ stuck 문제 발견\n   - Review 3: **No blocking issues - Production ready**\n\n**Edge\
  \ Cases 처리**: ✅ 타이핑 중 커서 점프 (main issue) ✅ Focus 중 외부 업데이트 누락 방지 ✅ Flush로 인한 stale\
  \ overwrite 방지 ✅ Stuck isProgrammaticUpdate flag 방지 ✅ ReadOnly toggle during focus\
  \ 처리 ✅ ReadOnly 모드에서 flag stuck 방지\n\n**수정 파일**:\n\n- `dashboard-v2/src/components/MarkdownEditor/MarkdownEditor.tsx`\n\
  \n**변경 사항**:\n\n```typescript\n// 1. 새로운 refs 추가 (line 44-45)\nconst isFocused =\
  \ useRef(false)\nconst pendingExternalValue = useRef<string | null>(null)\n\n//\
  \ 2. onUpdate - isProgrammaticUpdate 체크 우선 (line 127-143)\nonUpdate: ({ editor })\
  \ => {\n  // CRITICAL: Check BEFORE readOnly to avoid stuck flag\n  if (isProgrammaticUpdate.current)\
  \ {\n    isProgrammaticUpdate.current = false\n    return\n  }\n  if (readOnly)\
  \ return\n  const markdown = getMarkdownFromEditor(editor)\n  debouncedOnChange(markdown)\n\
  }\n\n// 3. onFocus handler 추가 (line 144-146)\nonFocus: () => {\n  isFocused.current\
  \ = true\n}\n\n// 4. onBlur handler 개선 (line 147-175)\nonBlur: () => {\n  isFocused.current\
  \ = false\n\n  // Flush BEFORE pending apply\n  if (!readOnly) {\n    debouncedOnChange.flush()\n\
  \  }\n\n  // Apply pending (ALWAYS, even in readOnly)\n  if (pendingExternalValue.current\
  \ !== null && editor) {\n    const currentMarkdown = getMarkdownFromEditor(editor)\n\
  \    if (pendingExternalValue.current !== currentMarkdown) {\n      isProgrammaticUpdate.current\
  \ = true\n      editor.commands.setContent(pendingExternalValue.current)\n     \
  \ lastValue.current = pendingExternalValue.current\n    }\n    pendingExternalValue.current\
  \ = null\n  }\n\n  if (!readOnly) {\n    onBlur?.()\n  }\n}\n\n// 5. External value\
  \ sync useEffect (line 191-195)\nif (isFocused.current) {\n  pendingExternalValue.current\
  \ = value\n  return\n}\n```\n\n**Codex Review 결과**:\n\n- **Iteration 1**: \"External\
  \ updates missed if readOnly becomes true during focus\"\n  - 수정: pending apply를\
  \ readOnly guard 밖으로 이동\n- **Iteration 2**: \"isProgrammaticUpdate can remain stuck\
  \ if setContent in readOnly\"\n  - 수정: onUpdate에서 flag 체크를 readOnly 체크보다 먼저\n- **Iteration\
  \ 3**: \"No blocking issues found\"\n  - Residual risks: readOnly toggle 테스트, 빈번한\
  \ 외부 업데이트 테스트 권장\n\n**빌드 검증**:\n\n```bash\ncd dashboard-v2 && pnpm build\n✓ TypeScript\
  \ compilation successful\n✓ Vite build complete (2.63s)\n✓ No errors\n```\n\n**최종\
  \ 상태**: Implementation Complete\n\n- ✅ 모든 edge case 처리 완료\n- ✅ Codex code review\
  \ 통과 (no blocking issues)\n- ✅ Build 성공\n- ⏳ 로컬 테스트 대기 (사용자 검증 필요)\n\n**Testing\
  \ Suggestions** (Codex 권장):\n\n1. readOnly toggle during focus with queued external\
  \ updates\n2. Typing while receiving frequent external updates (cursor stability)\n\
  \n**남은 작업**:\n\n- [ ] 로컬 Dashboard 실행 및 수동 테스트\n\n- [ ] 커서 점프 문제 해결 확인\n\n- [ ]\
  \ Task status → done\n\n---\n\n### 2026-01-12 (Revision 1 Implementation Complete)\n\
  \n**개요**: Text loss bug 수정 완료 - pendingExternalValue 로직 완전 제거\n\n**문제 요약**:\n\n\
  - 이전 구현의 `pendingExternalValue` 로직이 새로운 텍스트 손실 버그 유발\n- Race condition: flush(비동기)\
  \ vs pendingExternalValue(동기) → 최신 입력 손실\n\n**구현 내용** (Revision 1):\n\n1. **pendingExternalValue\
  \ ref 제거** (line 45)\n\n   ```typescript\n   // 삭제: const pendingExternalValue =\
  \ useRef<string | null>(null)\n   ```\n\n2. **onBlur handler 단순화** (lines 146-154)\n\
  \n   ```typescript\n   onBlur: () => {\n     isFocused.current = false\n   \n  \
  \   // Flush any pending debounced changes (Notion-style: sync on blur)\n     if\
  \ (!readOnly) {\n       debouncedOnChange.flush()\n       onBlur?.()\n     }\n \
  \  }\n   ```\n\n   - 기존: flush → pending 적용 (race condition 발생)\n   - 변경: flush만\
  \ 수행 (단순하고 안전)\n\n3. **External value sync useEffect 단순화** (lines 176-180)\n\n \
  \  ```typescript\n   // If focused, ignore external value changes (Notion-style)\n\
  \   // User input takes priority, server value will sync naturally on next focus\n\
  \   if (isFocused.current) {\n     return  // 저장하지 않고 그냥 무시\n   }\n   ```\n\n  \
  \ - 기존: pending에 저장\n   - 변경: 완전히 무시 (진정한 Notion 방식)\n\n**수정 파일**:\n\n- `/dashboard-v2/src/components/MarkdownEditor/MarkdownEditor.tsx`\n\
  \n**변경 통계**:\n\n- 삭제: 1 ref, \\~20 lines (pending 관리 로직)\n- 추가: 0 lines (단순화)\n\
  - 순 감소: \\~21 lines\n\n**빌드 검증**:\n\n```bash\ncd dashboard-v2 && pnpm build\n✓ TypeScript\
  \ compilation successful\n✓ Vite build complete (2.94s)\n✓ No errors\n✓ dist/index-CqVydf7F.js:\
  \ 278.19 kB (gzip: 81.62 kB)\n```\n\n**해결된 문제**: ✅ Text loss bug (main issue of\
  \ Revision 1) ✅ Race condition between flush and pending apply ✅ Simpler mental\
  \ model (no pending state to manage) ✅ Cursor jump still prevented (original issue\
  \ remains fixed)\n\n**Edge Cases 처리** (Notion-style):\n\n| Case | 처리 방식 | 결과 |\n\
  | --- | --- | --- |\n| Focus 중 서버 값 변경 | 완전히 무시 | 사용자 입력 우선 ✅ |\n| Blur 후 서버 값과\
  \ 차이 | flush로 최신 상태 저장 | 서버 sync ✅ |\n| 다음 Focus 시 | 서버 최신 값으로 시작 | 자연스러운 동기화 ✅\
  \ |\n| ReadOnly 상태 | 외부 값 즉시 적용 | 기존 로직 유지 ✅ |\n\n**최종 상태**: Revision 1 Implementation\
  \ Complete\n\n- ✅ pendingExternalValue 완전 제거\n- ✅ onBlur 단순화 (flush만 수행)\n- ✅ useEffect\
  \ 단순화 (focused면 그냥 return)\n- ✅ Build 성공\n- ⏳ 로컬 테스트 대기 (텍스트 손실 수정 확인)\n\n**테스트\
  \ 권장 사항**:\n\n1. **텍스트 손실 테스트** (Revision 1 main issue):\n\n   - Notes에서 \"A는 B와\"\
  \ 입력 → 대기 (API 저장)\n   - 이어서 \" 싸운다\" 입력 → 즉시 blur\n   - 확인: \"A는 B와 싸운다\" 전체 보존\
  \ (손실 없음)\n\n2. **커서 점프 테스트** (Original issue):\n\n   - Notes에서 긴 문장 타이핑\n   - 확인:\
  \ 커서가 중간에 점프하지 않음\n\n**코드 품질**:\n\n- ✅ No race conditions (pending 제거로 원천 차단)\n\
  - ✅ Simpler code (21 lines 감소)\n- ✅ Better maintainability (fewer states to manage)\n\
  - ✅ TypeScript type safety maintained\n\n**구현 완료**: Ready for user testing and `/done-dev-task`"
---
# Dashboard - Notes 편집 시 커서 점프 버그 수정

## PRD (from Plan Mode)

### 문제
- Task Drawer에서 notes 작성 시 커서가 갑자기 맨 아래로 이동
- 버벅거림 현상 동반
- 주기적으로 발생

### 원인
1. notes 입력 → 300ms debounce → API 저장
2. API 성공 → `invalidateQueries(task(id))` → task refetch
3. 서버 응답으로 MarkdownEditor value 업데이트
4. `editor.commands.setContent(value)` 호출 → 커서가 끝으로 리셋

### 해결 방안
**편집 중(focus)일 때는 외부 value 변경을 무시**

### 수정 파일
`dashboard-v2/src/components/MarkdownEditor/MarkdownEditor.tsx`

### 변경 내용

#### 1. focus 상태 추적 ref 추가
```typescript
const isFocused = useRef(false)
```

#### 2. useEditor에서 focus/blur 이벤트 처리
```typescript
onFocus: () => {
  isFocused.current = true
},
onBlur: () => {
  isFocused.current = false
  // 기존 blur 로직...
},
```

#### 3. 외부 value 동기화 useEffect에서 focus 체크
```typescript
useEffect(() => {
  if (!editor) return
  if (isInitialMount.current) { ... }

  // 편집 중이면 외부 value 무시 (노션 방식)
  if (isFocused.current) return

  if (value === lastValue.current) return
  // ... 나머지 로직
}, [value, editor])
```

---

---

## Revision History

### Revision 1 (2026-01-12) - Text Loss Bug

**Issue**: pendingExternalValue 로직이 새로운 텍스트 손실 버그를 일으킴

**Problem Description**:
- Notes 편집 시 작성 중인 내용이 갑자기 사라짐
- 예시: "A는 B와 싸운다" 입력 → "싸운다"가 사라지고 "A는 B와"만 남음

**Root Cause Analysis**:
1. 사용자: "A는 B와" 입력 → API 저장 (debounced)
2. 서버 응답 → `pendingExternalValue = "A는 B와"` 저장됨
3. 사용자: "싸운다" 추가 (에디터 상태: "A는 B와 싸운다")
4. blur 발생:
   - `flush("A는 B와 싸운다")` → 비동기 실행 (서버 전송)
   - `pendingExternalValue("A는 B와")` → 동기 적용 (즉시 에디터 덮어쓰기)
   - 결과: "싸운다" 손실

**Race Condition**:
```
Timeline:
  T1: 사용자 "A는 B와" 입력
  T2: debounce timer fires → API 저장
  T3: API 응답 → pendingExternalValue = "A는 B와"
  T4: 사용자 "싸운다" 추가
  T5: blur → flush(비동기) + pendingExternalValue(동기)
  T6: pendingExternalValue가 먼저 적용 → 최신 입력 손실!
```

**Fix Direction**:
- pendingExternalValue 로직 **완전 제거**
- focus 중에는 외부 value 변경 **완전 무시**
- blur 시에는 flush만 수행 (진정한 Notion-style)
- 결론: 더 단순한 접근 = 더 안전한 접근

---

## Additional Requirements (Revision 1)

### 변경 목표
1. **pendingExternalValue ref 완전 제거**
2. **onBlur에서 pending 적용 로직 제거** - flush만 수행
3. **외부 value sync useEffect에서 단순화** - focused면 그냥 return

### 수정 전 코드 (문제 있음)
```typescript
// refs
const pendingExternalValue = useRef<string | null>(null)

// onBlur
onBlur: () => {
  isFocused.current = false
  debouncedOnChange.flush()
  // 문제: pendingExternalValue가 flush보다 먼저 동기 적용됨
  if (pendingExternalValue.current !== null && editor) {
    isProgrammaticUpdate.current = true
    editor.commands.setContent(pendingExternalValue.current)
    // ...
  }
}

// useEffect
if (isFocused.current) {
  pendingExternalValue.current = value  // 문제: 저장해둠
  return
}
```

### 수정 후 코드 (Notion-style)
```typescript
// refs - pendingExternalValue 제거!
// const pendingExternalValue = useRef<string | null>(null) // 삭제

// onBlur - 단순화
onBlur: () => {
  isFocused.current = false
  if (!readOnly) {
    debouncedOnChange.flush()  // flush만 수행
    onBlur?.()
  }
}

// useEffect - 단순화
if (isFocused.current) {
  return  // 편집 중이면 그냥 무시 (저장하지 않음)
}
```

### 왜 이게 더 안전한가?
1. **No race condition**: pending 값 자체가 없으므로 충돌 불가
2. **Simpler mental model**: focus = 로컬 권위, blur = 서버와 sync
3. **Notion 방식**: 사용자 입력 우선, 서버 값은 다음 focus 시 자연스럽게 반영

### Edge Case 처리
| Case | 처리 방식 |
|------|----------|
| Focus 중 서버 값 변경 | 무시 (사용자 입력 우선) |
| Blur 후 서버 값과 차이 | flush로 최신 상태 저장됨 |
| 다음 Focus 시 | 서버 최신 값으로 시작 (refetch 결과) |
| ReadOnly 상태 | 외부 값 즉시 적용 (기존 로직 유지) |

---

## 체크리스트 (Revision 1)

### 이전 완료 항목
- [x] MarkdownEditor에 isFocused ref 추가
- [x] useEditor에 onFocus/onBlur 핸들러 추가
- [x] useEffect에서 focus 상태 체크 추가
- [x] Codex plan validation (3 iterations)
- [x] Implementation with all edge cases
- [x] Codex code review (3 iterations, no blocking issues)
- [x] Build verification (TypeScript compilation passed)

### Revision 1 신규 항목
- [ ] pendingExternalValue ref 제거
- [ ] onBlur에서 pending 적용 로직 제거
- [ ] useEffect에서 pending 저장 로직 제거
- [ ] Build verification
- [ ] 로컬 테스트: 텍스트 손실 버그 수정 확인
- [ ] 로컬 테스트: 커서 점프 여전히 방지되는지 확인

## 검증 방법

### 기존 테스트 (커서 점프)
1. Dashboard 로컬 실행: `cd public/dashboard-v2 && pnpm dev`
2. Task Drawer 열기
3. Notes 영역에서 긴 문장 타이핑
4. 커서가 중간에 점프하지 않는지 확인
5. blur 후 다시 focus → 서버 값과 동기화되는지 확인

### Revision 1 테스트 (텍스트 손실)
1. Task Drawer의 Notes에서 문장 작성: "A는 B와"
2. 잠시 대기 (debounce 완료, API 저장됨)
3. 이어서 추가 입력: " 싸운다"
4. 즉시 blur (다른 영역 클릭)
5. **확인**: "A는 B와 싸운다" 전체가 보존되어야 함 (손실 없음)
6. 다시 focus → 저장된 값 확인

## 참고

---

## 작업 로그

### 2026-01-12 (Implementation Complete)

**개요**: MarkdownEditor 커서 점프 버그 수정 완료 (Codex-Claude Loop 적용)

**문제 분석**:
- 사용자 타이핑 → 300ms debounce → API 저장
- API 성공 → invalidateQueries → task refetch
- 서버 응답으로 value prop 업데이트
- useEffect가 editor.commands.setContent() 호출
- setContent()가 커서를 끝으로 리셋

**해결 방안 (Notion-style)**:
- 편집 중(focus)일 때는 외부 value 변경을 pending으로 저장
- blur 시에만 pending 값 적용
- 여러 edge case 처리 (Codex 피드백 기반)

**구현 내용**:

1. **Phase 1: Planning**
   - 문제 원인 분석 완료
   - 초기 구현 계획 수립

2. **Phase 2: Codex Plan Validation** (3 iterations)
   - Iteration 1: 외부 업데이트 누락 문제 발견
   - Iteration 2: Flush 순서 문제 및 stuck flag 문제 발견
   - Iteration 3: 개선된 계획 검증 완료

3. **Phase 3: Implementation**
   - isFocused ref 추가 (focus 상태 추적)
   - pendingExternalValue ref 추가 (focus 중 외부 업데이트 저장)
   - onFocus handler 추가
   - onBlur handler 구현:
     * flush BEFORE applying pending (stale overwrite 방지)
     * content diff check (stuck flag 방지)
     * readOnly 상태에서도 pending 적용 (sync 보장)
   - onUpdate handler 수정:
     * isProgrammaticUpdate 체크를 readOnly 체크보다 먼저 (stuck flag 방지)
   - External value sync useEffect 수정:
     * focused 상태면 pending에 저장
     * 아니면 즉시 적용

4. **Phase 4: Codex Code Review** (3 iterations)
   - Review 1: readOnly toggle 시 pending 미적용 문제 발견
   - Review 2: readOnly 모드에서 isProgrammaticUpdate stuck 문제 발견
   - Review 3: **No blocking issues - Production ready**

**Edge Cases 처리**:
✅ 타이핑 중 커서 점프 (main issue)
✅ Focus 중 외부 업데이트 누락 방지
✅ Flush로 인한 stale overwrite 방지
✅ Stuck isProgrammaticUpdate flag 방지
✅ ReadOnly toggle during focus 처리
✅ ReadOnly 모드에서 flag stuck 방지

**수정 파일**:
- `dashboard-v2/src/components/MarkdownEditor/MarkdownEditor.tsx`

**변경 사항**:
```typescript
// 1. 새로운 refs 추가 (line 44-45)
const isFocused = useRef(false)
const pendingExternalValue = useRef<string | null>(null)

// 2. onUpdate - isProgrammaticUpdate 체크 우선 (line 127-143)
onUpdate: ({ editor }) => {
  // CRITICAL: Check BEFORE readOnly to avoid stuck flag
  if (isProgrammaticUpdate.current) {
    isProgrammaticUpdate.current = false
    return
  }
  if (readOnly) return
  const markdown = getMarkdownFromEditor(editor)
  debouncedOnChange(markdown)
}

// 3. onFocus handler 추가 (line 144-146)
onFocus: () => {
  isFocused.current = true
}

// 4. onBlur handler 개선 (line 147-175)
onBlur: () => {
  isFocused.current = false

  // Flush BEFORE pending apply
  if (!readOnly) {
    debouncedOnChange.flush()
  }

  // Apply pending (ALWAYS, even in readOnly)
  if (pendingExternalValue.current !== null && editor) {
    const currentMarkdown = getMarkdownFromEditor(editor)
    if (pendingExternalValue.current !== currentMarkdown) {
      isProgrammaticUpdate.current = true
      editor.commands.setContent(pendingExternalValue.current)
      lastValue.current = pendingExternalValue.current
    }
    pendingExternalValue.current = null
  }

  if (!readOnly) {
    onBlur?.()
  }
}

// 5. External value sync useEffect (line 191-195)
if (isFocused.current) {
  pendingExternalValue.current = value
  return
}
```

**Codex Review 결과**:
- **Iteration 1**: "External updates missed if readOnly becomes true during focus"
  - 수정: pending apply를 readOnly guard 밖으로 이동
- **Iteration 2**: "isProgrammaticUpdate can remain stuck if setContent in readOnly"
  - 수정: onUpdate에서 flag 체크를 readOnly 체크보다 먼저
- **Iteration 3**: "No blocking issues found"
  - Residual risks: readOnly toggle 테스트, 빈번한 외부 업데이트 테스트 권장

**빌드 검증**:
```bash
cd dashboard-v2 && pnpm build
✓ TypeScript compilation successful
✓ Vite build complete (2.63s)
✓ No errors
```

**최종 상태**: Implementation Complete
- ✅ 모든 edge case 처리 완료
- ✅ Codex code review 통과 (no blocking issues)
- ✅ Build 성공
- ⏳ 로컬 테스트 대기 (사용자 검증 필요)

**Testing Suggestions** (Codex 권장):
1. readOnly toggle during focus with queued external updates
2. Typing while receiving frequent external updates (cursor stability)

**남은 작업**:
- [ ] 로컬 Dashboard 실행 및 수동 테스트
- [ ] 커서 점프 문제 해결 확인
- [ ] Task status → done

---

### 2026-01-12 (Revision 1 Implementation Complete)

**개요**: Text loss bug 수정 완료 - pendingExternalValue 로직 완전 제거

**문제 요약**:
- 이전 구현의 `pendingExternalValue` 로직이 새로운 텍스트 손실 버그 유발
- Race condition: flush(비동기) vs pendingExternalValue(동기) → 최신 입력 손실

**구현 내용** (Revision 1):

1. **pendingExternalValue ref 제거** (line 45)
   ```typescript
   // 삭제: const pendingExternalValue = useRef<string | null>(null)
   ```

2. **onBlur handler 단순화** (lines 146-154)
   ```typescript
   onBlur: () => {
     isFocused.current = false

     // Flush any pending debounced changes (Notion-style: sync on blur)
     if (!readOnly) {
       debouncedOnChange.flush()
       onBlur?.()
     }
   }
   ```
   - 기존: flush → pending 적용 (race condition 발생)
   - 변경: flush만 수행 (단순하고 안전)

3. **External value sync useEffect 단순화** (lines 176-180)
   ```typescript
   // If focused, ignore external value changes (Notion-style)
   // User input takes priority, server value will sync naturally on next focus
   if (isFocused.current) {
     return  // 저장하지 않고 그냥 무시
   }
   ```
   - 기존: pending에 저장
   - 변경: 완전히 무시 (진정한 Notion 방식)

**수정 파일**:
- `/dashboard-v2/src/components/MarkdownEditor/MarkdownEditor.tsx`

**변경 통계**:
- 삭제: 1 ref, ~20 lines (pending 관리 로직)
- 추가: 0 lines (단순화)
- 순 감소: ~21 lines

**빌드 검증**:
```bash
cd dashboard-v2 && pnpm build
✓ TypeScript compilation successful
✓ Vite build complete (2.94s)
✓ No errors
✓ dist/index-CqVydf7F.js: 278.19 kB (gzip: 81.62 kB)
```

**해결된 문제**:
✅ Text loss bug (main issue of Revision 1)
✅ Race condition between flush and pending apply
✅ Simpler mental model (no pending state to manage)
✅ Cursor jump still prevented (original issue remains fixed)

**Edge Cases 처리** (Notion-style):
| Case | 처리 방식 | 결과 |
|------|----------|------|
| Focus 중 서버 값 변경 | 완전히 무시 | 사용자 입력 우선 ✅ |
| Blur 후 서버 값과 차이 | flush로 최신 상태 저장 | 서버 sync ✅ |
| 다음 Focus 시 | 서버 최신 값으로 시작 | 자연스러운 동기화 ✅ |
| ReadOnly 상태 | 외부 값 즉시 적용 | 기존 로직 유지 ✅ |

**최종 상태**: Revision 1 Implementation Complete
- ✅ pendingExternalValue 완전 제거
- ✅ onBlur 단순화 (flush만 수행)
- ✅ useEffect 단순화 (focused면 그냥 return)
- ✅ Build 성공
- ⏳ 로컬 테스트 대기 (텍스트 손실 수정 확인)

**테스트 권장 사항**:
1. **텍스트 손실 테스트** (Revision 1 main issue):
   - Notes에서 "A는 B와" 입력 → 대기 (API 저장)
   - 이어서 " 싸운다" 입력 → 즉시 blur
   - 확인: "A는 B와 싸운다" 전체 보존 (손실 없음)

2. **커서 점프 테스트** (Original issue):
   - Notes에서 긴 문장 타이핑
   - 확인: 커서가 중간에 점프하지 않음

**코드 품질**:
- ✅ No race conditions (pending 제거로 원천 차단)
- ✅ Simpler code (21 lines 감소)
- ✅ Better maintainability (fewer states to manage)
- ✅ TypeScript type safety maintained

**구현 완료**: Ready for user testing and `/done-dev-task`
