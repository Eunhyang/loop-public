---
entity_type: Task
entity_id: tsk-023-1769401037143
entity_name: Dashboard - Entity CRUD Mutation 공통화 및 Hypothesis Body 버그 수정
created: '2026-01-26'
updated: '2026-01-26'
status: done
project_id: prj-023
parent_id: prj-023
assignee: 김은향
priority: medium
tags: []
type: dev
aliases:
- tsk-023-1769401037143
start_date: '2026-01-26'
due: '2026-01-26'
---

# Dashboard - Entity CRUD Mutation 공통화 및 Hypothesis Body 버그 수정

## 설명

Hypothesis body 편집 시 내용이 사라졌다가 다시 나타나는 버그를 수정하고, Entity CRUD Mutation 로직을 공통화.

## 체크리스트

- [x] `src/queries/useEntityMutation.ts` 생성
- [x] `src/features/strategy/queries.ts` - useUpdateHypothesis 교체
- [x] npm run build 통과
- [x] code-simplifier 실행

## 참고

## 짧은 회고

## Notes

### Summary
Hypothesis body 편집 시 `invalidateQueries` 사용으로 인한 race condition 버그를 수정. 공통 Entity Update Mutation Factory(`useEntityUpdate`)를 생성하여 SSOT 확보.

### Changes Made
- **NEW** `dashboard-v2/src/queries/useEntityMutation.ts` - 공통 Mutation Factory
- **MODIFIED** `dashboard-v2/src/features/strategy/queries.ts` - useUpdateHypothesis가 공통 Factory 사용하도록 변경

### Plan

# Entity CRUD Mutation 공통화 + Hypothesis Body 버그 수정

## 문제 요약

1. **버그**: Dashboard v2에서 Hypothesis body 편집 시 내용이 사라졌다가 다시 나타남
2. **근본 원인**: Task/Project/Hypothesis가 같은 Form(`useEntityFormState`)을 쓰지만 mutation hook이 각각 다르게 구현됨

## 현재 구조의 문제점

| 레이어 | 공통화 | 문제 |
|--------|--------|------|
| Form State | `useEntityFormState` **공통** | 없음 |
| CRUD Mutations | **개별** (3곳) | 일관성 없음, 버그 발생 |

### 엔티티별 구현 차이

| 항목 | Task | Project | Hypothesis |
|------|------|---------|------------|
| body→_body 변환 | 없음 | **있음** | 없음 |
| 409 처리 | `handleConflictError` | 없음 | inline |
| onSuccess | 없음 | **setQueryData** | `invalidateQueries` (버그!) |

## 해결 방안: 공통 Mutation Factory

### 1. 새 파일 생성: `src/queries/useEntityMutation.ts`

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { queryKeys } from './keys';
import { handleConflictError } from './invalidation';
import type { DashboardInitResponse } from '@/types';

// 지원하는 엔티티 타입
type EntityType = 'task' | 'project' | 'hypothesis' | 'track' | 'condition';

// 엔티티 타입 → dashboardInit 배열 키 매핑
const COLLECTION_KEYS: Record<EntityType, keyof DashboardInitResponse> = {
  task: 'tasks',
  project: 'projects',
  hypothesis: 'hypotheses',
  track: 'tracks',
  condition: 'conditions',
};

// body → _body 변환이 필요한 엔티티
const NEEDS_BODY_TRANSFORM: EntityType[] = ['project', 'hypothesis'];

/**
 * body → _body 변환 (캐시 일관성 유지)
 * API는 body 사용, 캐시는 _body 사용
 */
function transformBodyField<T extends Record<string, unknown>>(data: T): T {
  const result = { ...data };
  if ('body' in result) {
    (result as Record<string, unknown>)._body = result.body;
    delete (result as Record<string, unknown>).body;
  }
  return result;
}

interface UseEntityUpdateOptions<T> {
  entityType: EntityType;
  mutationFn: (id: string, data: Partial<T>) => Promise<T>;
}

/**
 * 공통 Entity Update Mutation Hook Factory
 *
 * Features:
 * - Optimistic update with rollback
 * - body → _body 변환 (필요한 엔티티만)
 * - 409 Conflict 처리
 * - invalidateQueries 대신 setQueryData 사용 (race condition 방지)
 */
export function useEntityUpdate<T extends { entity_id: string }>({
  entityType,
  mutationFn,
}: UseEntityUpdateOptions<T>) {
  const queryClient = useQueryClient();
  const collectionKey = COLLECTION_KEYS[entityType];
  const needsBodyTransform = NEEDS_BODY_TRANSFORM.includes(entityType);

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<T> }) =>
      mutationFn(id, data),

    onMutate: async ({ id, data }) => {
      // 1. Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: queryKeys.dashboardInit });

      // 2. Snapshot for rollback
      const previousDashboard = queryClient.getQueryData<DashboardInitResponse>(
        queryKeys.dashboardInit
      );

      // 3. Transform body → _body if needed
      const cacheData = needsBodyTransform ? transformBodyField(data) : data;

      // 4. Optimistic update
      if (previousDashboard) {
        const collection = previousDashboard[collectionKey] as T[];
        queryClient.setQueryData(queryKeys.dashboardInit, {
          ...previousDashboard,
          [collectionKey]: collection.map((item) =>
            item.entity_id === id ? { ...item, ...cacheData } : item
          ),
        });
      }

      return { previousDashboard };
    },

    onError: (error, _variables, context) => {
      // Handle 409 Conflict
      handleConflictError(queryClient, error);

      // Rollback optimistic update
      if (context?.previousDashboard) {
        queryClient.setQueryData(queryKeys.dashboardInit, context.previousDashboard);
      }
    },

    onSuccess: (_response, { id, data }) => {
      // Use request data (not server response) to update cache
      // Server response may contain null values that overwrite valid data
      const cacheData = needsBodyTransform ? transformBodyField(data) : data;

      queryClient.setQueryData<DashboardInitResponse>(queryKeys.dashboardInit, (old) => {
        if (!old) return old;
        const collection = old[collectionKey] as T[];
        return {
          ...old,
          [collectionKey]: collection.map((item) =>
            item.entity_id === id ? { ...item, ...cacheData } : item
          ),
        };
      });
      // Note: invalidateQueries 제거 - race condition 방지
    },
  });
}
```

### 2. 기존 파일 수정

#### 2.1 `tasks/queries.ts` - useUpdateTask

```typescript
// Before: 50+ lines of custom implementation
// After:
import { useEntityUpdate } from '@/queries/useEntityMutation';
import { taskApi } from './api';
import type { Task } from '@/types';

export const useUpdateTask = () => {
  return useEntityUpdate<Task>({
    entityType: 'task',
    mutationFn: (id, data) => taskApi.updateTask(id, data).then(res => res.data),
  });
};
```

#### 2.2 `projects/queries.ts` - useUpdateProject

```typescript
// Before: 60+ lines with body→_body transform
// After:
import { useEntityUpdate } from '@/queries/useEntityMutation';
import { projectApi } from './api';
import type { Project } from '@/types';

export const useUpdateProject = () => {
  return useEntityUpdate<Project>({
    entityType: 'project',
    mutationFn: (id, data) => projectApi.updateProject(id, data).then(res => res.data),
  });
};
```

#### 2.3 `strategy/queries.ts` - useUpdateHypothesis

```typescript
// Before: invalidateQueries 사용 (버그 원인)
// After:
import { useEntityUpdate } from '@/queries/useEntityMutation';
import { hypothesisApi } from './api';
import type { Hypothesis } from '@/types/hypothesis';

export const useUpdateHypothesis = () => {
  return useEntityUpdate<Hypothesis>({
    entityType: 'hypothesis',
    mutationFn: (id, data) => hypothesisApi.updateHypothesis(id, data).then(res => res.data),
  });
};
```

## 파일 변경 목록

| 파일 | 작업 |
|------|------|
| `src/queries/useEntityMutation.ts` | **새로 생성** |
| `src/queries/index.ts` | export 추가 |
| `src/features/tasks/queries.ts` | useUpdateTask 교체 |
| `src/features/projects/queries.ts` | useUpdateProject 교체 |
| `src/features/strategy/queries.ts` | useUpdateHypothesis 교체 |

## 검증 방법

### 1. 빌드 확인
```bash
cd ~/dev/loop/code/dashboard-v2
npm run build
```

### 2. 기능 테스트

**Task 편집:**
- Dashboard에서 Task 열기
- notes 필드 수정 후 저장
- 내용이 유지되는지 확인

**Project 편집:**
- Dashboard에서 Project 열기
- body 필드 수정 후 저장
- 내용이 유지되는지 확인 (기존과 동일하게 동작)

**Hypothesis 편집 (버그 수정 확인):**
- Dashboard에서 Hypothesis 열기
- body 필드에 텍스트 입력
- 저장 버튼 클릭
- **내용이 사라지지 않고 유지되어야 함**

### 3. 409 Conflict 테스트
- 두 브라우저에서 동시에 같은 엔티티 편집
- 한쪽 저장 후 다른쪽 저장 시도
- 409 에러 발생 시 캐시 refresh 확인

## 영향 범위

- **장점**:
  - SSOT 확보 (mutation 로직 1곳에서 관리)
  - 향후 새 엔티티 추가 시 일관된 동작 보장
  - 코드 중복 제거 (~150줄 → ~50줄)

- **리스크**:
  - 기존 동작 회귀 가능성 (테스트 필수)
  - Track, Condition도 추후 동일 패턴 적용 고려

## 향후 확장

Track/Condition update도 동일 패턴 적용 가능:
```typescript
export const useUpdateTrack = () => {
  return useEntityUpdate<Track>({
    entityType: 'track',
    mutationFn: (id, data) => trackApi.updateTrack(id, data).then(res => res.data),
  });
};
```
