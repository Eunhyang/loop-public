---
entity_type: Task
entity_id: tsk-1kthoh-1768994658583
entity_name: Ontology Lite v1 - project_kind, hypothesis_kind추가
created: '2026-01-21'
updated: '2026-01-21'
status: doing
closed: '2026-01-19'
project_id: prj-1kthoh
parent_id: prj-1kthoh
assignee: 김은향
priority: medium
start_date: '2026-01-21'
due: '2026-01-21'
aliases:
- tsk-1kthoh-1768994658583
tags: []
type: dev
_path: 50_Projects/2026/P1_Ontology_Vault_Ontology_Lite_v1/Tasks/tsk-1kthoh-1768841096537.md
_body: "# Ontology Lite v1 - Strategic Context 매핑 함수 PRD 작성\n\n## 문제\n\nStrategic\
  \ Context는 일부 구조화되어 있어도, 관계 의미가 런타임에서 흔들릴 수 있다. 매핑 함수를 통해 결정론적 그래프 변환이 필요하다.\n\n\
  ## 목표\n\nStrategic Context 입력(JSON/필드/문서)을 받아 **Ontology Lite v1 nodes/edges로 결정론적으로\
  \ 변환**하는 규칙/테이블/인터페이스를 PRD로 확정한다.\n\n## 입력/출력\n\n### Input\n\n- project/track/condition/hypothesis\
  \ raw context(JSON)\n- (옵션) 문서 body(마크다운)\n\n### Output\n\n- nodes: `[{id, type,\
  \ name, attrs...}]`\n- edges: `[{type, from, to, weight?, description?, evidence?}]`\n\
  - diagnostics: 누락/충돌/불확실성 로그\n\n## 매핑 규칙(초안)\n\n- `validates[]` → validates edge\
  \ 생성\n- `condition_contributes[]` → enables edge(+weight)\n- `outgoing_relations[]`\
  \ → edge_types에 따라 매핑(허용 밖이면 diagnostics)\n- `validated_by` 같은 역방향 필드는 **중복 방지 위해\
  \ 생성하지 않고 조회 시 파생**\n\n## 완료 기준\n\n- [ ] \"입력필드 → edge_type\" 매핑 테이블 완비\n- [ ] 샘플\
  \ 5개 입력에 대한 expected nodes/edges 스냅샷 포함\n\n## 참고\n\n- Parent Project: [[prj-1kthoh]]\n\
  \n## 짧은 회고\n\n### 2026-01-19 23:30\n**개요**: normalize_strategic_context() 구현 완료\
  \ 및 build_strategic_context()에 통합\n\n**변경사항**:\n- 개발: `api/utils/normalize_strategic_context.py`\
  \ - 결정론적 그래프 변환 핵심 로직\n- 수정: `api/prompts/context_builder.py` - include_graph 옵션\
  \ 추가로 정규화된 그래프 포함 지원\n- 개발: `api/tests/test_normalize_strategic_context.py` - 12개\
  \ 단위 테스트 (PRD Sample 1-5 기반)\n\n**파일 변경**:\n- `api/utils/normalize_strategic_context.py`\
  \ (새로 생성)\n  - normalize_strategic_context() - Strategic Context → nodes/edges 변환\n\
  \  - EDGE_TYPES 스키마 정의 (validates, enables, depends_on, unlocks, breaks, terminates)\n\
  \  - Diagnostics 클래스 - errors/warnings/info 수집\n  - 결정론성 보장: 동일 입력 → 동일 순서 출력 (sorted\
  \ by type, id)\n  - 중복 제거: dedup_policy (weight: max, note: first_non_null)\n  -\
  \ 시맨틱 충돌 해결: enables vs depends_on → depends_on 우선\n  - Stub node 생성: 참조 대상 미존재\
  \ 시 Unknown 타입 노드 생성\n\n- `api/prompts/context_builder.py` (수정)\n  - build_strategic_context()에\
  \ include_graph 파라미터 추가\n  - _format_graph_result() 추가 - 정규화된 그래프를 프롬프트용 텍스트로 포맷\n\
  \n- `api/tests/test_normalize_strategic_context.py` (새로 생성)\n  - 12개 테스트 케이스: PRD\
  \ Sample 1-5 + 추가 엣지 케이스\n  - ✓ validates/condition_contributes 처리\n  - ✓ outgoing_relations\
  \ 필터링\n  - ✓ validated_by 무시 (reverse field)\n  - ✓ 시맨틱 충돌 해결\n  - ✓ stub node 생성\n\
  \  - ✓ weight 범위 검증\n  - ✓ 결정론적 순서\n  - ✓ edge 중복 제거\n\n**테스트 결과**: ✅ 핵심 시나리오 검증\
  \ 완료\n\n**구현 세부**:\n1. Edge 생성 규칙 (PRD 매핑 테이블 완전 준수)\n   - validates[] → validates\
  \ edge (evidence 없으면 warning)\n   - condition_contributes[] → enables edge (weight\
  \ 0-1 범위 검증)\n   - outgoing_relations[] → allowed_outgoing_types만 허용\n   - validated_by[]\
  \ → 무시 (info 로그만)\n\n2. 스키마 검증\n   - EDGE_TYPES 제약 (from/to type) 강제 적용\n   - 위반\
  \ 시 error + edge 생성 안 함\n   - Unknown 타입은 warning으로 허용\n\n3. 데이터 흐름\n   - raw_context\
  \ 입력 → entities 평탄화 → nodes 생성 → edges 생성 → 스키마 검증 → 중복 제거 → 충돌 해결 → 정렬 → 반환\n\n\
  **결과**:\n- PRD 완료 기준 달성\n  - ✅ 입력필드 → edge_type 매핑 테이블 완비\n  - ✅ 5개 샘플 expected\
  \ snapshot 일치\n  - ✅ 결정론성 보장 (동일 입력 → 동일 결과)\n- build_strategic_context()에서 호출 가능\
  \ (include_graph=True)\n- Agent가 정규화된 그래프 컨텍스트 활용 가능"
notes: "## 1) Project에 `project_kind`(= intent) 추가: “이 프로젝트는 뭘 검증하려는 프로젝트인가?”\n\n\
  ### 목적\n\nProject는 “유일한 판정 단위”라서(SSOT_CONTRACT에도 있음), 프로젝트가 **Signal용인지 / Adoption용인지\
  \ / Impact용인지**를 명시하면\n\n- 칸반/캘린더/리뷰에서 프로젝트 성격이 즉시 보이고\n\n- 같은 Track 안에서도 “지금은 수요검증(신호)\
  \ 단계인지 / 사용검증(채택) 단계인지 / 효과검증(임팩트) 단계인지”가 구조화됨\n\n- 이후 자동 롤업(예: Track에 Signal 프로젝트가\
  \ 몇 개, Impact 프로젝트가 몇 개)도 가능해짐\n\n### 어디에 넣어야 SSOT가 되나?\n\n`schema_constants.yaml`에\
  \ 최소 4군데:\n\n1. **enum 값 정의**: `project:` 섹션 아래에 `kinds:` 추가\n\n2. **known_fields.Project**에\
  \ 필드 추가 (스키마가 “아는 필드”가 됨)\n\n3. **write_targets.Project.writable_fields**에 추가 (대시보드/API에서\
  \ 수정 허용하려면)\n\n4. (선택) **required_fields.Project**에 넣을지 결정 (나는 *필수는 비추*, 점진 도입이\
  \ 안전)\n\n---\n\n## 2) Hypothesis에 `hypothesis_kind`: Signal / Adoption / Impact\
  \ 추가\n\n### 네가 적어준 3종 분류를 “가설의 타입”으로 SSOT에 박는 것\n\n- Signal: “사람들이 원하는가?”\n\n- Adoption:\
  \ “실제로 쓰는가?”\n\n- Impact: “문제가 해결되는가?”\n\n이건 Hypothesis가 “무슨 질문인지”를 더 명확히 하는 메타라서,\
  \ Hypothesis에 `hypothesis_kind`(또는 `kind`)로 넣는 게 정석이야.\\\n(Project에도 `project_kind`를\
  \ 넣는 이유는 **프로젝트가 ‘무슨 종류의 검증 실행’인지**를 명시하려고고, Hypothesis는 **검증 질문 자체의 타입**을 명시하려고.)\n\
  \n---\n\n## 3) schema_constants.yaml에 들어갈 **구체 변경안(추천안: Project.project_kind + Hypothesis.hypothesis_kind)**\n\
  \n> 아래는 “추가해야 하는 블록”만 모아둔 패치 형태야. (YAML이라 코드블록으로 제공)\n\n```\n# ============================================\n\
  # Project\n# ============================================\nproject:\n  status:\n\
  \    - planning\n    - doing\n    - done\n    - hold\n    - cancelled\n  status_default:\
  \ planning\n  status_labels:\n    planning: \"Planning\"\n    doing: \"Doing\"\n\
  \    done: \"Done\"\n    hold: \"Hold\"\n    cancelled: \"Cancelled\"\n  status_colors:\n\
  \    planning: \"#6b7280\"\n    doing: \"#3b82f6\"\n    done: \"#10b981\"\n    hold:\
  \ \"#f59e0b\"\n    cancelled: \"#ef4444\"\n\n  # \U0001F195 프로젝트 의도/종류 (intent)\n\
  \  kinds:\n    - signal     # 관심/수요 검증: \"사람들이 원하는가?\"\n    - adoption   # 사용/습관\
  \ 검증: \"실제로 쓰는가?\"\n    - impact     # 문제 해결/가치 검증: \"문제가 해결되는가?\"\n  kind_default:\
  \ signal\n  kind_labels:\n    signal: \"Signal\"\n    adoption: \"Adoption\"\n \
  \   impact: \"Impact\"\n```\n\n```\n# ============================================\n\
  # Hypothesis (가설 상태)\n# ============================================\nhypothesis:\n\
  \  evidence_status:\n    - assumed\n    - validating\n    - validated\n    - falsified\n\
  \    - learning\n\n  # \U0001F195 가설 타입 (Signal / Adoption / Impact)\n  kinds:\n\
  \    - signal\n    - adoption\n    - impact\n  kind_default: signal\n  kind_labels:\n\
  \    signal: \"Signal (Demand)\"\n    adoption: \"Adoption (Usage)\"\n    impact:\
  \ \"Impact (Value)\"\n```\n\n```\n# ============================================\n\
  # Known Fields ...\n# ============================================\nknown_fields:\n\
  \  ...\n  Project:\n    - owner\n    - summary\n    - start_date\n    - budget\n\
  \    - deadline\n    - program_id\n    - cycle\n    - project_kind          # \U0001F195\
  \ 추가\n    - expected_impact\n    - realized_impact\n    ...\n\n  Hypothesis:\n \
  \   - hypothesis_kind       # \U0001F195 추가\n    - hypothesis_question\n    - start_date\n\
  \    ...\n```\n\n```\n# ============================================\n# Write Targets\
  \ ...\n# ============================================\nwrite_targets:\n  writable_fields:\n\
  \    Project:\n      - status\n      - owner\n      - start_date\n      - deadline\n\
  \      - summary\n      - expected_impact\n      - realized_impact\n      - notes\n\
  \      - conditions_3y\n      - condition_contributes\n      - track_contributes\n\
  \      - entity_name\n      - parent_id\n      - program_id\n      - priority_flag\n\
  \      - validates\n      - primary_hypothesis_id\n      - links\n      - attachments\n\
  \      - tags\n      - project_kind     # \U0001F195 추가\n\n    Hypothesis:\n   \
  \   - status\n      - evidence_status\n      - confidence\n      - start_date\n\
  \      - deadline\n      - notes\n      - entity_name\n      - parent_id\n     \
  \ - hypothesis_question\n      - success_criteria\n      - failure_criteria\n  \
  \    - measurement\n      - horizon\n      - loop_layer\n      - tags\n      - hypothesis_kind\
  \  # \U0001F195 추가\n```\n\n```\n# (선택) Validation Rules에 enum 검증 규칙을 넣고 싶으면\nvalidation_rules:\n\
  \  format_rules:\n    ...\n    Project:\n      project_kind: \"must be one of [signal,\
  \ adoption, impact]\"\n    Hypothesis:\n      hypothesis_kind: \"must be one of\
  \ [signal, adoption, impact]\"\n```\n\n> **주의:** 지금 파일 구조상 `format_rules`가 “문자열\
  \ 규칙 설명” 위주라, 실제 enforce는 `validate_schema.py`에서 해줘야 “진짜 강제”가 돼.\\\n> 하지만 SSOT는\
  \ 일단 `schema_constants.yaml`에 값 정의가 들어가면 “공식 enum”이 생기고, validator가 그걸 읽어 enforce하도록\
  \ 맞추는 흐름이야.\n\n---\n\n## 4) 네가 적어준 3종 분류 텍스트는 “SSOT에 어디에 담나?”\n\n네 설명(목적/실험/지표/결론)은\
  \ **스키마 상수 파일(schema_constants.yaml**)에 길게 넣기보다는:\n\n- `schema_constants.yaml`에는\
  \ **타입(enum)만**: `signal/adoption/impact`\n\n- 상세 정의는 `00_Meta/` 문서(예: `Hypothesis_Templates_Pack.md`\
  \ 또는 새 문서 `Hypothesis_Kinds.md`)에 넣는 게 “드리프트 방지 + 가독성”이 좋아.\n\n다만 네 요청이 “SSOT”라서,\
  \ **최소 SSOT로는 enum + labels + writable_fields + known_fields**까지가 핵심이고, 그건 위 패치로\
  \ 충족돼.\n\n---\n\n원하는 방향이 이거 맞지?\n\n- Project에 `project_kind`(= intent)로 **Signal/Adoption/Impact\
  \ 중 하나를 박아서** “이 프로젝트가 뭘 검증하려는 실행인지”가 보이게 하고\n\n- Hypothesis에 `hypothesis_kind`로\
  \ **가설 질문 자체의 타입**을 박는다"
start_time: 01:30
end_time: 02:30
---
# Ontology Lite v1 - Strategic Context 매핑 함수 PRD 작성

## 문제

Strategic Context는 일부 구조화되어 있어도, 관계 의미가 런타임에서 흔들릴 수 있다. 매핑 함수를 통해 결정론적 그래프 변환이 필요하다.

## 목표

Strategic Context 입력(JSON/필드/문서)을 받아 **Ontology Lite v1 nodes/edges로 결정론적으로 변환**하는 규칙/테이블/인터페이스를 PRD로 확정한다.

## 입력/출력

### Input

- project/track/condition/hypothesis raw context(JSON)
- (옵션) 문서 body(마크다운)

### Output

- nodes: `[{id, type, name, attrs...}]`
- edges: `[{type, from, to, weight?, description?, evidence?}]`
- diagnostics: 누락/충돌/불확실성 로그

## 매핑 규칙(초안)

- `validates[]` → validates edge 생성
- `condition_contributes[]` → enables edge(+weight)
- `outgoing_relations[]` → edge_types에 따라 매핑(허용 밖이면 diagnostics)
- `validated_by` 같은 역방향 필드는 **중복 방지 위해 생성하지 않고 조회 시 파생**

## 완료 기준

- [ ] "입력필드 → edge_type" 매핑 테이블 완비
- [ ] 샘플 5개 입력에 대한 expected nodes/edges 스냅샷 포함

## 참고

- Parent Project: [[prj-1kthoh]]

## 짧은 회고

### 2026-01-19 23:30
**개요**: normalize_strategic_context() 구현 완료 및 build_strategic_context()에 통합

**변경사항**:
- 개발: `api/utils/normalize_strategic_context.py` - 결정론적 그래프 변환 핵심 로직
- 수정: `api/prompts/context_builder.py` - include_graph 옵션 추가로 정규화된 그래프 포함 지원
- 개발: `api/tests/test_normalize_strategic_context.py` - 12개 단위 테스트 (PRD Sample 1-5 기반)

**파일 변경**:
- `api/utils/normalize_strategic_context.py` (새로 생성)
  - normalize_strategic_context() - Strategic Context → nodes/edges 변환
  - EDGE_TYPES 스키마 정의 (validates, enables, depends_on, unlocks, breaks, terminates)
  - Diagnostics 클래스 - errors/warnings/info 수집
  - 결정론성 보장: 동일 입력 → 동일 순서 출력 (sorted by type, id)
  - 중복 제거: dedup_policy (weight: max, note: first_non_null)
  - 시맨틱 충돌 해결: enables vs depends_on → depends_on 우선
  - Stub node 생성: 참조 대상 미존재 시 Unknown 타입 노드 생성

- `api/prompts/context_builder.py` (수정)
  - build_strategic_context()에 include_graph 파라미터 추가
  - _format_graph_result() 추가 - 정규화된 그래프를 프롬프트용 텍스트로 포맷

- `api/tests/test_normalize_strategic_context.py` (새로 생성)
  - 12개 테스트 케이스: PRD Sample 1-5 + 추가 엣지 케이스
  - ✓ validates/condition_contributes 처리
  - ✓ outgoing_relations 필터링
  - ✓ validated_by 무시 (reverse field)
  - ✓ 시맨틱 충돌 해결
  - ✓ stub node 생성
  - ✓ weight 범위 검증
  - ✓ 결정론적 순서
  - ✓ edge 중복 제거

**테스트 결과**: ✅ 핵심 시나리오 검증 완료

**구현 세부**:
1. Edge 생성 규칙 (PRD 매핑 테이블 완전 준수)
   - validates[] → validates edge (evidence 없으면 warning)
   - condition_contributes[] → enables edge (weight 0-1 범위 검증)
   - outgoing_relations[] → allowed_outgoing_types만 허용
   - validated_by[] → 무시 (info 로그만)

2. 스키마 검증
   - EDGE_TYPES 제약 (from/to type) 강제 적용
   - 위반 시 error + edge 생성 안 함
   - Unknown 타입은 warning으로 허용

3. 데이터 흐름
   - raw_context 입력 → entities 평탄화 → nodes 생성 → edges 생성 → 스키마 검증 → 중복 제거 → 충돌 해결 → 정렬 → 반환

**결과**:
- PRD 완료 기준 달성
  - ✅ 입력필드 → edge_type 매핑 테이블 완비
  - ✅ 5개 샘플 expected snapshot 일치
  - ✅ 결정론성 보장 (동일 입력 → 동일 결과)
- build_strategic_context()에서 호출 가능 (include_graph=True)
- Agent가 정규화된 그래프 컨텍스트 활용 가능
