---
entity_type: Task
entity_id: tsk-1kthoh-1768878418480
entity_name: Ontology Lite v1 - Offering (PaywallOffer) 최소 스펙 + GTM SSOT 설계 + 구현 ToDo
  (v1.1)
created: '2026-01-20'
updated: '2026-01-20'
status: doing
closed: '2026-01-19'
project_id: prj-1kthoh
parent_id: prj-1kthoh
assignee: 김은향
priority: high
start_date: '2026-01-21'
due: '2026-01-21'
aliases:
- tsk-1kthoh-1768878418480
tags: []
type: strategy
_path: 50_Projects/2025/P1_Ontology_Vault_Ontology_Lite_v1/Tasks/tsk-1kthoh-1768841096537.md
_body: "# Ontology Lite v1 - Strategic Context 매핑 함수 PRD 작성\n\n## 문제\n\nStrategic\
  \ Context는 일부 구조화되어 있어도, 관계 의미가 런타임에서 흔들릴 수 있다. 매핑 함수를 통해 결정론적 그래프 변환이 필요하다.\n\n\
  ## 목표\n\nStrategic Context 입력(JSON/필드/문서)을 받아 **Ontology Lite v1 nodes/edges로 결정론적으로\
  \ 변환**하는 규칙/테이블/인터페이스를 PRD로 확정한다.\n\n## 입력/출력\n\n### Input\n\n- project/track/condition/hypothesis\
  \ raw context(JSON)\n- (옵션) 문서 body(마크다운)\n\n### Output\n\n- nodes: `[{id, type,\
  \ name, attrs...}]`\n- edges: `[{type, from, to, weight?, description?, evidence?}]`\n\
  - diagnostics: 누락/충돌/불확실성 로그\n\n## 매핑 규칙(초안)\n\n- `validates[]` → validates edge\
  \ 생성\n- `condition_contributes[]` → enables edge(+weight)\n- `outgoing_relations[]`\
  \ → edge_types에 따라 매핑(허용 밖이면 diagnostics)\n- `validated_by` 같은 역방향 필드는 **중복 방지 위해\
  \ 생성하지 않고 조회 시 파생**\n\n## 완료 기준\n\n- [ ] \"입력필드 → edge_type\" 매핑 테이블 완비\n- [ ] 샘플\
  \ 5개 입력에 대한 expected nodes/edges 스냅샷 포함\n\n## 참고\n\n- Parent Project: [[prj-1kthoh]]\n\
  \n## 짧은 회고\n\n### 2026-01-19 23:30\n**개요**: normalize_strategic_context() 구현 완료\
  \ 및 build_strategic_context()에 통합\n\n**변경사항**:\n- 개발: `api/utils/normalize_strategic_context.py`\
  \ - 결정론적 그래프 변환 핵심 로직\n- 수정: `api/prompts/context_builder.py` - include_graph 옵션\
  \ 추가로 정규화된 그래프 포함 지원\n- 개발: `api/tests/test_normalize_strategic_context.py` - 12개\
  \ 단위 테스트 (PRD Sample 1-5 기반)\n\n**파일 변경**:\n- `api/utils/normalize_strategic_context.py`\
  \ (새로 생성)\n  - normalize_strategic_context() - Strategic Context → nodes/edges 변환\n\
  \  - EDGE_TYPES 스키마 정의 (validates, enables, depends_on, unlocks, breaks, terminates)\n\
  \  - Diagnostics 클래스 - errors/warnings/info 수집\n  - 결정론성 보장: 동일 입력 → 동일 순서 출력 (sorted\
  \ by type, id)\n  - 중복 제거: dedup_policy (weight: max, note: first_non_null)\n  -\
  \ 시맨틱 충돌 해결: enables vs depends_on → depends_on 우선\n  - Stub node 생성: 참조 대상 미존재\
  \ 시 Unknown 타입 노드 생성\n\n- `api/prompts/context_builder.py` (수정)\n  - build_strategic_context()에\
  \ include_graph 파라미터 추가\n  - _format_graph_result() 추가 - 정규화된 그래프를 프롬프트용 텍스트로 포맷\n\
  \n- `api/tests/test_normalize_strategic_context.py` (새로 생성)\n  - 12개 테스트 케이스: PRD\
  \ Sample 1-5 + 추가 엣지 케이스\n  - ✓ validates/condition_contributes 처리\n  - ✓ outgoing_relations\
  \ 필터링\n  - ✓ validated_by 무시 (reverse field)\n  - ✓ 시맨틱 충돌 해결\n  - ✓ stub node 생성\n\
  \  - ✓ weight 범위 검증\n  - ✓ 결정론적 순서\n  - ✓ edge 중복 제거\n\n**테스트 결과**: ✅ 핵심 시나리오 검증\
  \ 완료\n\n**구현 세부**:\n1. Edge 생성 규칙 (PRD 매핑 테이블 완전 준수)\n   - validates[] → validates\
  \ edge (evidence 없으면 warning)\n   - condition_contributes[] → enables edge (weight\
  \ 0-1 범위 검증)\n   - outgoing_relations[] → allowed_outgoing_types만 허용\n   - validated_by[]\
  \ → 무시 (info 로그만)\n\n2. 스키마 검증\n   - EDGE_TYPES 제약 (from/to type) 강제 적용\n   - 위반\
  \ 시 error + edge 생성 안 함\n   - Unknown 타입은 warning으로 허용\n\n3. 데이터 흐름\n   - raw_context\
  \ 입력 → entities 평탄화 → nodes 생성 → edges 생성 → 스키마 검증 → 중복 제거 → 충돌 해결 → 정렬 → 반환\n\n\
  **결과**:\n- PRD 완료 기준 달성\n  - ✅ 입력필드 → edge_type 매핑 테이블 완비\n  - ✅ 5개 샘플 expected\
  \ snapshot 일치\n  - ✅ 결정론성 보장 (동일 입력 → 동일 결과)\n- build_strategic_context()에서 호출 가능\
  \ (include_graph=True)\n- Agent가 정규화된 그래프 컨텍스트 활용 가능"
notes: "# Offering (PaywallOffer) 최소 스펙 + GTM SSOT 설계 + 구현 ToDo (v1.1)\n\n## 0) 결론:\
  \ 왜 Offering이 필요한가 (최소 정의)\n\n- **Project** = “기간이 있는 실행 단위(개발/런칭/캠페인/릴리즈 트레인)”\n\
  \n- **Offering** = “가격/권한/기간/결제조건을 가진 **상시적 상업 오브젝트**(플랜/페이월 패키지)”\n\n- “앱 구독/전면\
  \ 유료화”는 **앱(Project)의 속성**이 아니라, 앱에 붙는 **Offering(오퍼/권한 정책)** 이라서 별도 엔티티가 더 안정적임.\n\
  \n---\n\n## 1) Offering 최소 스펙: 무엇이 있어야 ‘그래프가 흔들리지’ 않는가\n\n### 1.1 필수(Required) —\
  \ v0\n\n> 이 정도만 있으면 GTM 그래프에서 “업셀/수익화”가 결정론적으로 질의 가능\n\n- entity_type: `Offering`\n\
  \n- entity_id: `off-...` (예: `off-app-subscription-v1`)\n\n- entity_name: 사람 읽기용\
  \ 이름 (예: `앱 구독 v1 (전면 유료화)`)\n\n- status: planning/doing/done/hold\n\n- owner: 담당\
  \ (팀/개인)\n\n- **attached_to**: 어떤 제품/표면에 붙는가 (예: `prj-app-kkokkkok` 또는 `trk-1`)\n\
  \n  - v1에서는 **Project에 붙이는 것을 추천** (Track은 방향이고, 실제 노출/전환 지점은 보통 Project/UI라서)\n\
  \n- billing_model: `subscription | one_time | usage_based`\n\n- price: 숫자 (예: 9900)\n\
  \n- currency: `KRW`\n\n- period: `month | year | week` (subscription일 때)\n\n- entitlements:\
  \ “유료로 열리는 권한 목록(짧게라도)”\n\n  - 예: `[dashboard_insight, personalization, replay_full]`\n\
  \n- free_scope: “항상 무료로 남겨둘 범위” (Emergency Brake 정책 고정)\n\n  - 예: `quick_brake_30s`,\
  \ `recovery_start_1m`\n\n- success_metrics: 오퍼 성과를 보는 최소 지표 2\\~4개\n\n  - 예: `paywall_view_to_purchase`,\
  \ `trial_to_paid`, `churn_30d`, `arppu`\n\n### 1.2 권장(Recommended) — v0.1\n\n- segment_rules:\
  \ 어떤 세그먼트/조건에 노출되는지\n\n  - 예: `glp1_off`, `high_pupi_cohort`\n\n- paywall_surface:\
  \ 노출 위치(앱 화면/리포트/결과페이지 등)\n\n- trial: `{type: free_trial, days: 7}` 같은 최소 구조\n\n\
  - constraints: “절대 바꾸면 안 되는 규칙” (예: Emergency Brake Free 고정)\n\n### 1.3 옵션(Optional)\n\
  \n- pricing_variants: 월/연/프로모션 등 변형\n\n- experiment_links: A/B 테스트 id나 실험 문서 링크\n\
  \n- evidence: 가격/권한을 이렇게 설계한 근거(정성/정량)\n\n---\n\n## 2) Offering 문서 템플릿 (복붙용)\n\n\
  ---\n\nentity_type: Offering\\\nentity_id: off-app-subscription-v1\\\nentity_name:\
  \ 앱 구독 v1 (전면 유료화)\\\ncreated: 2026-01-20\\\nupdated: 2026-01-20\\\nstatus: planning\\\
  \nowner: Product Team\\\nattached_to: prj-app-kkokkkok\\\nbilling_model: subscription\\\
  \nprice: 9900\\\ncurrency: KRW\\\nperiod: month\\\nentitlements:\n\n- dashboard_insight\n\
  \n- personalization\n\n- replay_full\\\n  free_scope:\n\n- quick_brake_30s\n\n-\
  \ recovery_start_1m\\\n  success_metrics:\n\n- paywall_view_to_purchase\n\n- trial_to_paid\n\
  \n- churn_30d\n\n- arppu\\\n  segment_rules:\n\n- high_pupi_cohort\\\n  constraints:\n\
  \n- \"Emergency Brake는 Quick Brake(15\\~30초) + 회복 시작(첫 1분)까지만 Free\"\n\n---\n\n\
  # Offering: 앱 구독 v1 (전면 유료화)\n\n## 한 줄 정의\n\n앱의 프리미엄 레이어(대시보드/인사이트/개인화/리플레이)를 구독으로\
  \ 판매하는 오퍼.\n\n## 왜 필요한가\n\n- Project(앱/릴리즈)와 분리해 가격/권한 정책을 안정적으로 진화시키기 위함.\n\n##\
  \ 권한(Entitlements)\n\n- dashboard_insight: ...\n\n- personalization: ...\n\n- replay_full:\
  \ ...\n\n## Free 범위(고정)\n\n- quick_brake_30s\n\n- recovery_start_1m\n\n## 측정(성공\
  \ 지표)\n\n- paywall_view_to_purchase: ...\n\n- trial_to_paid: ...\n\n- churn_30d:\
  \ ...\n\n- arppu: ...\n\n---\n\n## 3) GTM SSOT 문서 설계: 20_Strategy/GTM/GTM_Subgraph.md\
  \ (v1.1)\n\n### 원칙\n\n- GTM은 “기간 있는 프로젝트”를 하드코딩하는 게 아니라,\n\n  - **Project(실행/표면)**\
  \ + **Offering(가격/권한)** + (필요시) Track(앵커) 조합으로 표현\n\n- GTM_Subgraph는 **관계(Edges)\
  \ SSOT**, 각 노드의 상세는 **각 엔티티 문서가 SSOT**\n\n### GTM_Subgraph.md에 들어갈 것\n\n- \\[GTM_SUBGRAPH\\\
  ] 블록 1개\n\n  - Nodes: id/type 최소만(가능하면 title/role만)\n\n  - Edges: edge_types.yaml\
  \ 제약을 100% 만족하는 타입만\n\n---\n\n## 4) Edge Types 재정의(스키마 위반 방지: Offering 도입 버전)\n\n\
  > 지금 에러의 본질은 “Track이 GTM 퍼널의 송신자/수신자처럼 쓰인 것”\\\n> GTM 퍼널은 보통 **Project(UI/채널/제품표면)**\
  \ 과 **Offering(결제오퍼)** 사이에서 일어남.\n\n### 추천 GTM Edge Types (v1.1)\n\n- gtm_activates_into\n\
  \n  - from: \\[Project\\]\n\n  - to: \\[Project\\]\n\n  - 의미: 유입/콘텐츠/랜딩이 앱 활성(설치/가입/핵심행동)으로\
  \ 전환\n\n- gtm_upsells_to\n\n  - from: \\[Project\\]\n\n  - to: \\[Offering\\]\n\n\
  \  - 의미: 활성 사용자 → 결제 오퍼로 업셀\n\n- gtm_monetized_by\n\n  - from: \\[Offering\\]\n\n\
  \  - to: \\[Track\\]\n\n  - 의미: 특정 오퍼 매출이 Revenue Track KPI를 구성\n\n(선택) gtm_retained_by\n\
  \n- from: \\[Project\\]\n\n- to: \\[Project\\]\n\n- 의미: 리텐션 루프(앱 기능/콘텐츠/코칭이 유지로\
  \ 기여)\n\n---\n\n## 5) \\[GTM_SUBGRAPH\\] v1.1 예시 (스키마 위반 0)\n\n## \\[GTM_SUBGRAPH\\\
  ] v1.1\n\n### Nodes\n\n- id: prj-content-youtube\\\n  type: Project\\\n  attrs:\
  \ { gtm_role: acquisition_channel }\n\n- id: prj-app-kkokkkok\\\n  type: Project\\\
  \n  attrs: { gtm_role: activation_product }\n\n- id: off-app-subscription-v1\\\n\
  \  type: Offering\\\n  attrs: { gtm_role: monetization_offer, billing_model: subscription\
  \ }\n\n- id: trk-6\\\n  type: Track\\\n  attrs: { gtm_role: revenue_track }\n\n\
  ### Edges\n\n- type: gtm_activates_into\\\n  from_id: prj-content-youtube\\\n  to_id:\
  \ prj-app-kkokkkok\\\n  note: 콘텐츠 유입을 앱 설치/활성으로 전환\\\n  evidence: \"YouTube CTA\
  \ → 랜딩/스토어/딥링크 퍼널\"\n\n- type: gtm_upsells_to\\\n  from_id: prj-app-kkokkkok\\\n\
  \  to_id: off-app-subscription-v1\\\n  note: 앱 사용자를 유료 오퍼로 업셀\\\n  evidence: \"\
  앱 내 paywall/리포트/성과 가시화 기반 전환\"\n\n- type: gtm_monetized_by\\\n  from_id: off-app-subscription-v1\\\
  \n  to_id: trk-6\\\n  note: 구독 매출이 Track_6_Revenue KPI를 구성\\\n  evidence: \"RevenueCat\
  \ 지표가 Track_6 KPI로 집계\"\n\n---\n\n## 6) 구현 ToDo (너가 말한 3개 + 보강 포함)\n\n### (A) Offering\
  \ 생성 + SSOT 보강 ✅ (네 1번)\n\n- Offering 엔티티 문서 1개 생성 (예: 20_Strategy/Offerings/off-app-subscription-v1.md\
  \ 또는 50_Projects 아래 별도 폴더)\n\n- Track_1_Product / Track_6_Revenue에는 “참조 링크/요약”만\
  \ 두고, 오퍼 자체 SSOT는 Offering 문서로 분리\n\n### (B) GTM SSOT 문서 생성 ✅ (네 2번)\n\n- `20_Strategy/GTM/GTM_Subgraph.md`\
  \ 생성\n\n- 이 문서가 GTM edges의 **유일 SSOT** (각 Track 문서에 흩뿌리지 않기)\n\n### (C) normalize_strategic_context\
  \ 반영 ✅ (네 3번)\n\n- 파서가 다음을 지원:\n\n  1. Offering entity_type 파싱 → node 생성\n\n  2.\
  \ GTM_Subgraph.md에서 \\[GTM_SUBGRAPH\\] 블록 파싱\n\n  3. 기존 Track/Project 문서에 있는 \\\
  [GTM_SUBGRAPH\\]가 있으면 **병합 규칙**(우선순위/중복제거) 적용\n\n     - v1.1 추천: **중앙 SSOT(GTM_Subgraph.md)\
  \ 우선**, 개별 문서 블록은 “로컬 오버레이”로만 허용(또는 금지)\n\n### (D) edge_types.yaml 업데이트 (필수)\n\n\
  - 위 v1.1 GTM edge 제약으로 스키마 갱신\n\n- 기존 Track→Project 형태는 **GTM edge로 쓰지 않기** (Track\
  \ 관계는 depends_on/contributes로 충분)\n\n### (E) Context Builder 동작 변경 (필수)\n\n- “GTM\
  \ 질문/의도”면 `20_Strategy/GTM/GTM_Subgraph.md`를 항상 include\n\n- “Revenue/구독/업셀/전환/가격/플랜”\
  \ 키워드 또는 대상 엔티티가 trk-6/offering이면 include\n\n### (F) 회귀 테스트 추가 (권장)\n\n- GTM_Subgraph\
  \ snapshot 1개 추가\n\n- 스키마 위반 0 보장\n\n---\n\n## 7) 너의 질문에 대한 최종 체크\n\n> “그럼 지금 해야하는것\
  \ 1) offering 생성 2) GTM SSOT 생성 3) normalizer 반영 맞아?”\n\n✅ 맞음.\\\n다만 **정확히는** 아래처럼\
  \ “스키마/컨텍스트 빌더”까지 포함해야 한번에 안 깨짐:\n\n- \n\n1. Offering 엔티티 생성 + 문서 SSOT 분리\n\n- \n\
  \n2. 20_Strategy/GTM/GTM_Subgraph.md SSOT 생성\n\n- \n\n3. edge_types.yaml에 Offering\
  \ 포함 GTM edge 제약 업데이트\n\n- \n\n4. normalize_strategic_context: Offering + GTM SSOT\
  \ 파싱/병합 반영\n\n- \n\n5. Context Builder: GTM 질의 시 GTM_Subgraph 항상 include"
start_time: 00:00
end_time: 01:00
---
# Ontology Lite v1 - Strategic Context 매핑 함수 PRD 작성

## 문제

Strategic Context는 일부 구조화되어 있어도, 관계 의미가 런타임에서 흔들릴 수 있다. 매핑 함수를 통해 결정론적 그래프 변환이 필요하다.

## 목표

Strategic Context 입력(JSON/필드/문서)을 받아 **Ontology Lite v1 nodes/edges로 결정론적으로 변환**하는 규칙/테이블/인터페이스를 PRD로 확정한다.

## 입력/출력

### Input

- project/track/condition/hypothesis raw context(JSON)
- (옵션) 문서 body(마크다운)

### Output

- nodes: `[{id, type, name, attrs...}]`
- edges: `[{type, from, to, weight?, description?, evidence?}]`
- diagnostics: 누락/충돌/불확실성 로그

## 매핑 규칙(초안)

- `validates[]` → validates edge 생성
- `condition_contributes[]` → enables edge(+weight)
- `outgoing_relations[]` → edge_types에 따라 매핑(허용 밖이면 diagnostics)
- `validated_by` 같은 역방향 필드는 **중복 방지 위해 생성하지 않고 조회 시 파생**

## 완료 기준

- [ ] "입력필드 → edge_type" 매핑 테이블 완비
- [ ] 샘플 5개 입력에 대한 expected nodes/edges 스냅샷 포함

## 참고

- Parent Project: [[prj-1kthoh]]

## 짧은 회고

### 2026-01-19 23:30
**개요**: normalize_strategic_context() 구현 완료 및 build_strategic_context()에 통합

**변경사항**:
- 개발: `api/utils/normalize_strategic_context.py` - 결정론적 그래프 변환 핵심 로직
- 수정: `api/prompts/context_builder.py` - include_graph 옵션 추가로 정규화된 그래프 포함 지원
- 개발: `api/tests/test_normalize_strategic_context.py` - 12개 단위 테스트 (PRD Sample 1-5 기반)

**파일 변경**:
- `api/utils/normalize_strategic_context.py` (새로 생성)
  - normalize_strategic_context() - Strategic Context → nodes/edges 변환
  - EDGE_TYPES 스키마 정의 (validates, enables, depends_on, unlocks, breaks, terminates)
  - Diagnostics 클래스 - errors/warnings/info 수집
  - 결정론성 보장: 동일 입력 → 동일 순서 출력 (sorted by type, id)
  - 중복 제거: dedup_policy (weight: max, note: first_non_null)
  - 시맨틱 충돌 해결: enables vs depends_on → depends_on 우선
  - Stub node 생성: 참조 대상 미존재 시 Unknown 타입 노드 생성

- `api/prompts/context_builder.py` (수정)
  - build_strategic_context()에 include_graph 파라미터 추가
  - _format_graph_result() 추가 - 정규화된 그래프를 프롬프트용 텍스트로 포맷

- `api/tests/test_normalize_strategic_context.py` (새로 생성)
  - 12개 테스트 케이스: PRD Sample 1-5 + 추가 엣지 케이스
  - ✓ validates/condition_contributes 처리
  - ✓ outgoing_relations 필터링
  - ✓ validated_by 무시 (reverse field)
  - ✓ 시맨틱 충돌 해결
  - ✓ stub node 생성
  - ✓ weight 범위 검증
  - ✓ 결정론적 순서
  - ✓ edge 중복 제거

**테스트 결과**: ✅ 핵심 시나리오 검증 완료

**구현 세부**:
1. Edge 생성 규칙 (PRD 매핑 테이블 완전 준수)
   - validates[] → validates edge (evidence 없으면 warning)
   - condition_contributes[] → enables edge (weight 0-1 범위 검증)
   - outgoing_relations[] → allowed_outgoing_types만 허용
   - validated_by[] → 무시 (info 로그만)

2. 스키마 검증
   - EDGE_TYPES 제약 (from/to type) 강제 적용
   - 위반 시 error + edge 생성 안 함
   - Unknown 타입은 warning으로 허용

3. 데이터 흐름
   - raw_context 입력 → entities 평탄화 → nodes 생성 → edges 생성 → 스키마 검증 → 중복 제거 → 충돌 해결 → 정렬 → 반환

**결과**:
- PRD 완료 기준 달성
  - ✅ 입력필드 → edge_type 매핑 테이블 완비
  - ✅ 5개 샘플 expected snapshot 일치
  - ✅ 결정론성 보장 (동일 입력 → 동일 결과)
- build_strategic_context()에서 호출 가능 (include_graph=True)
- Agent가 정규화된 그래프 컨텍스트 활용 가능
