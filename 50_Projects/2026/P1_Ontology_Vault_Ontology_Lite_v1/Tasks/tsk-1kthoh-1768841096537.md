---
entity_type: Task
entity_id: tsk-1kthoh-1768841096537
entity_name: 'Ontology Lite v1 - Strategic Context → Graph Normalizer (v1.1: GTM Subgraph
  Deterministic Merge)'
created: '2026-01-20'
updated: '2026-01-22'
status: doing
closed: '2026-01-19'
project_id: prj-1kthoh
parent_id: prj-1kthoh
assignee: 김은향
priority: high
start_date: '2026-01-24'
due: '2026-01-24'
aliases:
- tsk-1kthoh-1768841096537
tags: []
type: dev
_path: 50_Projects/2025/P1_Ontology_Vault_Ontology_Lite_v1/Tasks/tsk-1kthoh-1768748985191.md
_body: "# Ontology Lite v1 - Strategic Context 매핑 함수 PRD 작성\n\n## 문제\n\nStrategic\
  \ Context는 일부 구조화되어 있어도, 관계 의미가 런타임에서 흔들릴 수 있다. 매핑 함수를 통해 결정론적 그래프 변환이 필요하다.\n\n\
  ## 목표\n\nStrategic Context 입력(JSON/필드/문서)을 받아 **Ontology Lite v1 nodes/edges로 결정론적으로\
  \ 변환**하는 규칙/테이블/인터페이스를 PRD로 확정한다.\n\n## 입력/출력\n\n### Input\n\n- project/track/condition/hypothesis\
  \ raw context(JSON)\n- (옵션) 문서 body(마크다운)\n\n### Output\n\n- nodes: `[{id, type,\
  \ name, attrs...}]`\n- edges: `[{type, from, to, weight?, description?, evidence?}]`\n\
  - diagnostics: 누락/충돌/불확실성 로그\n\n## 매핑 규칙(초안)\n\n- `validates[]` → validates edge\
  \ 생성\n- `condition_contributes[]` → enables edge(+weight)\n- `outgoing_relations[]`\
  \ → edge_types에 따라 매핑(허용 밖이면 diagnostics)\n- `validated_by` 같은 역방향 필드는 **중복 방지 위해\
  \ 생성하지 않고 조회 시 파생**\n\n## 완료 기준\n\n- [ ] \"입력필드 → edge_type\" 매핑 테이블 완비\n- [ ] 샘플\
  \ 5개 입력에 대한 expected nodes/edges 스냅샷 포함\n\n## 참고\n\n- Parent Project: [[prj-1kthoh]]\n\
  \n## 짧은 회고\n\n### 2026-01-19 23:30\n**개요**: normalize_strategic_context() 구현 완료\
  \ 및 build_strategic_context()에 통합\n\n**변경사항**:\n- 개발: `api/utils/normalize_strategic_context.py`\
  \ - 결정론적 그래프 변환 핵심 로직\n- 수정: `api/prompts/context_builder.py` - include_graph 옵션\
  \ 추가로 정규화된 그래프 포함 지원\n- 개발: `api/tests/test_normalize_strategic_context.py` - 12개\
  \ 단위 테스트 (PRD Sample 1-5 기반)\n\n**파일 변경**:\n- `api/utils/normalize_strategic_context.py`\
  \ (새로 생성)\n  - normalize_strategic_context() - Strategic Context → nodes/edges 변환\n\
  \  - EDGE_TYPES 스키마 정의 (validates, enables, depends_on, unlocks, breaks, terminates)\n\
  \  - Diagnostics 클래스 - errors/warnings/info 수집\n  - 결정론성 보장: 동일 입력 → 동일 순서 출력 (sorted\
  \ by type, id)\n  - 중복 제거: dedup_policy (weight: max, note: first_non_null)\n  -\
  \ 시맨틱 충돌 해결: enables vs depends_on → depends_on 우선\n  - Stub node 생성: 참조 대상 미존재\
  \ 시 Unknown 타입 노드 생성\n\n- `api/prompts/context_builder.py` (수정)\n  - build_strategic_context()에\
  \ include_graph 파라미터 추가\n  - _format_graph_result() 추가 - 정규화된 그래프를 프롬프트용 텍스트로 포맷\n\
  \n- `api/tests/test_normalize_strategic_context.py` (새로 생성)\n  - 12개 테스트 케이스: PRD\
  \ Sample 1-5 + 추가 엣지 케이스\n  - ✓ validates/condition_contributes 처리\n  - ✓ outgoing_relations\
  \ 필터링\n  - ✓ validated_by 무시 (reverse field)\n  - ✓ 시맨틱 충돌 해결\n  - ✓ stub node 생성\n\
  \  - ✓ weight 범위 검증\n  - ✓ 결정론적 순서\n  - ✓ edge 중복 제거\n\n**테스트 결과**: ✅ 핵심 시나리오 검증\
  \ 완료\n\n**구현 세부**:\n1. Edge 생성 규칙 (PRD 매핑 테이블 완전 준수)\n   - validates[] → validates\
  \ edge (evidence 없으면 warning)\n   - condition_contributes[] → enables edge (weight\
  \ 0-1 범위 검증)\n   - outgoing_relations[] → allowed_outgoing_types만 허용\n   - validated_by[]\
  \ → 무시 (info 로그만)\n\n2. 스키마 검증\n   - EDGE_TYPES 제약 (from/to type) 강제 적용\n   - 위반\
  \ 시 error + edge 생성 안 함\n   - Unknown 타입은 warning으로 허용\n\n3. 데이터 흐름\n   - raw_context\
  \ 입력 → entities 평탄화 → nodes 생성 → edges 생성 → 스키마 검증 → 중복 제거 → 충돌 해결 → 정렬 → 반환\n\n\
  **결과**:\n- PRD 완료 기준 달성\n  - ✅ 입력필드 → edge_type 매핑 테이블 완비\n  - ✅ 5개 샘플 expected\
  \ snapshot 일치\n  - ✅ 결정론성 보장 (동일 입력 → 동일 결과)\n- build_strategic_context()에서 호출 가능\
  \ (include_graph=True)\n- Agent가 정규화된 그래프 컨텍스트 활용 가능"
notes: "# PRD + Tech Spec — Strategic Context → Graph Normalizer (v1.1: GTM Subgraph\
  \ Deterministic Merge)\n\n## 0. 요약\n\n`normalize_strategic_context(raw_context,\
  \ doc_body?, options?)`는 Strategic Context의 구조화 입력(raw_context)과 선택 입력(doc_body)을\
  \ 받아 **Ontology Lite v1 스키마에 맞는 nodes/edges/diagnostics를 “결정론적으로” 생성**한다.\n\nv1.1의\
  \ 핵심 추가점은 다음 1가지:\n\n- **doc_body에** `[GTM_SUBGRAPH]` **정형 블록이 존재하면, 해당 Nodes/Edges를\
  \ “추론 없이 그대로” 파싱하여 결과 그래프에 merge**한다.\n\n- 기존 v1 동작(구조화 필드 기반 edge 생성)은 유지하며, GTM은\
  \ “추가 레이어”로만 결합한다.\n\n---\n\n## 1. 배경 / 문제\n\n- 현재 매출/전환/업셀 구조(콘텐츠→앱→구독, 콘텐츠→코칭(앱동반),\
  \ 코칭데이터→앱가치→구독성장)는 자연어로만 존재하면 LLM/agent가 질의마다 **추론으로 관계를 재구성**해 흔들린다.\n\n- 이를 막기\
  \ 위해 GTM 관계를 `edge_types.yaml`에 \\*\\*고정된 의미(gtm\\_\\*)\\*\\*로 정의했고, Strategic Context에도\
  \ `[GTM_SUBGRAPH]`라는 **정형 블록**을 두어 “데이터로 박아” 결정론적으로 그래프에 포함시키려 한다.\n\n---\n\n##\
  \ 2. 목표 / 비목표\n\n### 목표\n\n- **GTM Subgraph를 결정론적으로 생성**: 같은 doc_body면 매번 동일 nodes/edges\
  \ (정렬 포함)\n\n- `edge_types.yaml`의 from/to 제약을 준수하며, 위반/누락은 diagnostics로 남김\n\n-\
  \ 기존 v1의 canonical forward field 기반 규칙은 유지 (회귀 0)\n\n### 비목표\n\n- 문서 본문에서 NLP로 새로운\
  \ 관계 추론 생성 (금지)\n\n- GTM edges의 weight/strength 자동 학습\n\n- Graph DB 저장/인덱싱/서빙 개선\
  \ (변환기 범위 밖)\n\n---\n\n## 3. 입력 / 출력\n\n### 3.1 Input\n\n- `raw_context` (필수): 기존\
  \ Strategic Context 구조화 JSON\n\n- `doc_body` (옵션): markdown 텍스트 (여기서 `[GTM_SUBGRAPH]`를\
  \ 파싱)\n\n- `options` (옵션)\n\n### 3.2 Output\n\n```json\n{\n  \"nodes\": [{\"id\"\
  ,\"type\",\"title\",\"attrs\"}],\n  \"edges\": [{\"type\",\"from_id\",\"to_id\"\
  ,\"weight?\",\"note?\",\"evidence?\",\"strength?\",\"measured_at?\",\"break_trigger?\"\
  }],\n  \"diagnostics\": {\"errors\":[],\"warnings\":[],\"info\":[]}\n}\n```\n\n\
  ---\n\n## 4. v1.1 변경점 (Delta)\n\n### 4.1 새 기능: GTM Subgraph 파싱\n\n- `doc_body` 내에\
  \ 아래 섹션이 존재하면 처리:\n\n  - 헤더: `## [GTM_SUBGRAPH] v1` (또는 `## [GTM_SUBGRAPH]`)\n\n\
  \  - 하위 섹션: `### Nodes`, `### Edges`\n\n- Nodes/Edges는 YAML list 형태로 작성된 템플릿을 그대로\
  \ 파싱한다.\n\n- 파싱 성공 시:\n\n  - GTM Nodes를 nodes_map에 upsert\n\n  - GTM Edges를 edges_list에\
  \ append\n\n  - 이후 기존 파이프라인과 동일하게 schema validation → dedup → conflict → deterministic\
  \ sort 수행\n\n### 4.2 새 옵션(권장)\n\n- `options.enable_doc_body_gtm: boolean` (default:\
  \ true)\n\n- `options.gtm_section_header: string` (default: \"\\[GTM_SUBGRAPH\\\
  ]\")\n\n- `options.gtm_version_allowlist: [\"v1\"]` (default: \\[\"v1\"\\])\n\n\
  - `options.strict_gtm_evidence: boolean` (default: false)\n\n  - false면 evidence\
  \ 누락은 warning, true면 error + drop(정책 선택)\n\n---\n\n## 5. GTM Subgraph 포맷 스펙 (Parser\
  \ Contract)\n\n### 5.1 허용 포맷\n\ndoc_body 내 다음 형태를 **정확히** 지원한다.\n\n- Nodes 블록: `-\
  \ id: ...` 로 시작하는 YAML list\n\n- Edges 블록: `- type: ...` 로 시작하는 YAML list\n\n###\
  \ 5.2 Node 필드\n\n필수:\n\n- `id`, `type`, `title`\\\n  선택:\n\n- `tags`, `attrs`(map),\
  \ 기타는 attrs로 흡수 가능\n\n정책:\n\n- `type`은 v1.1에서는 **기본 Track/Project만 강제 지원** (추후 확장\
  \ 가능)\n\n- type이 Unknown/미지원이면:\n\n  - `Unknown` stub로 강등 + warning `gtm_node_unknown_type`\n\
  \n### 5.3 Edge 필드\n\n필수:\n\n- `type`, `from_id`, `to_id`\\\n  선택:\n\n- `note`, `evidence`,\
  \ `weight`, `strength`, `measured_at`\n\n정책:\n\n- `type`은 `edge_types.yaml`에 존재해야\
  \ 함 (없으면 error `unknown_edge_type`)\n\n- from/to 제약 위반은 error `schema_violation`\
  \ 처리\n\n---\n\n## 6. 매핑 규칙 (전체)\n\nv1 rules는 그대로 유지하고, v1.1에서 **GTM edges만 추가 소스**로\
  \ 인정한다.\n\n### 6.1 Canonical Edge Sources\n\n- 구조화 필드: `validates[]`, `condition_contributes[]`,\
  \ `outgoing_relations[]` (기존)\n\n- 문서 필드: `[GTM_SUBGRAPH].Edges[]` (신규)\n\n### 6.2\
  \ Reverse Fields Ignore\n\n- `validated_by[]` 등 역방향 필드는 여전히 ignore (info 기록)\n\n\
  ### 6.3 Dedup Key\n\n- 유일키: `(type, from_id, to_id)`\n\n- GTM에서 동일키가 들어오면 기존 정책(예:\
  \ weight=max, note=first_non_null) 적용\n\n---\n\n## 7. 충돌/중복 의미 방지 (Conflict Rules)\n\
  \n기존 규칙 유지 + GTM 관련 추가:\n\n### 7.1 enables vs depends_on\n\n- 동일 from/to에 대해 `enables`\
  \ & `depends_on` 동시 존재 시:\n\n  - `depends_on` 유지, `enables` drop + warning `edge_semantic_conflict`\n\
  \n### 7.2 gtm\\_\\* vs 전략 edge\n\n- 같은 from/to에 대해 `gtm_*`와 `enables/depends_on/validates`는\
  \ **동시 존재 허용**\n\n  - 이유: 의미 레이어가 다름(“사업 현실” vs “전략 의사결정”)\n\n  - 단, retrieval에서\
  \ “질문 타입별 edge whitelist”로 컨텍스트를 통제한다(별도 라우팅 레이어)\n\n---\n\n## 8. 결정론(Determinism)\
  \ 요구사항\n\n- nodes sort: `(type asc, id asc)`\n\n- edges sort: `(type asc, from_id\
  \ asc, to_id asc)`\n\n- 문서 파싱 성공 여부/순서와 무관하게 결과는 stable해야 함:\n\n  - 노드/엣지 수집 후 마지막에\
  \ 정렬\n\n  - 동일 input이면 결과 JSON이 바이트 단위로 동일(스냅샷 테스트)\n\n---\n\n## 9. Diagnostics\
  \ (추가/변경)\n\n### Errors\n\n- `unknown_edge_type`\n\n- `schema_violation` (from/to\
  \ 제약 위반)\n\n- `gtm_parse_failed` (GTM 섹션 발견했으나 파싱 불가)\n\n- `gtm_missing_required_fields`\
  \ (id/type/title 또는 edge 필수필드 누락)\n\n### Warnings\n\n- `gtm_section_not_found` (doc_body\
  \ 있으나 GTM 섹션 없음)\n\n- `gtm_node_unknown_type`\n\n- `missing_evidence_for_gtm_edge`\
  \ (strict=false인 경우)\n\n- `gtm_edge_refs_missing_node` (stub 생성됨)\n\n### Info\n\n\
  - `gtm_section_parsed`\n\n- `stub_node_created`\n\n- `reverse_field_ignored`\n\n\
  ---\n\n## 10. 구현 Tech Spec (Pseudo-code 수준)\n\n### 10.1 High-level pipeline\n\n\
  \ 1. flatten_entities(raw_context) → entities\n\n 2. build nodes_map from entities\n\
  \n 3. build edges_list from canonical structured fields (v1)\n\n 4. **if doc_body\
  \ and enable_doc_body_gtm:**\n\n    - parse_gtm_subgraph(doc_body) → {gtm_nodes,\
  \ gtm_edges, parse_diag}\n\n    - merge nodes_map += gtm_nodes\n\n    - edges_list\
  \ += gtm_edges\n\n 5. ensure stubs for referenced ids (policy-driven)\n\n 6. schema\
  \ gatekeeping with edge_types.yaml\n\n 7. dedup edges by (type,from,to)\n\n 8. resolve\
  \ semantic conflicts (enables vs depends_on)\n\n 9. deterministic sort\n\n10. return\
  \ result\n\n### 10.2 parse_gtm_subgraph(doc_body)\n\n- Find header line containing\
  \ `[GTM_SUBGRAPH]` (exact token match)\n\n- Identify `### Nodes` block region, parse\
  \ YAML list\n\n- Identify `### Edges` block region, parse YAML list\n\n- Validate\
  \ minimal required fields\n\n- Return structured nodes/edges + diagnostics\n\nParser\
  \ implementation notes:\n\n- Markdown에서 YAML list만 파싱하면 되므로, “섹션 boundaries”만 안정적으로\
  \ 잡으면 됨\n\n- YAML 파서는 허용(이미 edge_types.yaml 등을 쓰는 시스템이라면 동일 파서 재사용)\n\n---\n\n##\
  \ 11. 수용 테스트(AC) / 회귀 테스트\n\n### 11.1 신규 AC (GTM)\n\n- Case A: doc_body에 GTM 템플릿\
  \ 포함\n\n  - nodes/edges에 `gtm_activates_into`, `gtm_includes`, `gtm_upsells_to`,\
  \ `gtm_monetized_by`, `gtm_data_feeds`가 포함\n\n  - 정렬 포함 스냅샷 100% 일치\n\n- Case B:\
  \ doc_body에 GTM 섹션 없음\n\n  - v1과 결과 동일(회귀 0)\n\n  - diagnostics.warning에 `gtm_section_not_found`\
  \ 추가 가능(옵션)\n\n- Case C: GTM edge type 오타\n\n  - errors: `unknown_edge_type`\n\n\
  \  - 해당 edge drop\n\n### 11.2 대표 질문 기반 스냅샷(라우팅과 결합 시)\n\n- “현재 결제 구조 설명” → GTM edges\
  \ 경로가 항상 포함\n\n- “코칭 데이터가 구독 성장에 어떻게 이어짐?” → gtm_data_feeds + gtm_upsells_to 경로\
  \ 포함\n\n---\n\n## 12. 기대 Output (정규화 결과 예시: 최소)\n\n```json\n{\n  \"nodes\": [\n\
  \    {\"id\":\"prj-content\",\"type\":\"Project\",\"title\":\"YouTube 1주 1업로드\"\
  , \"attrs\":{}},\n    {\"id\":\"prj-app\",\"type\":\"Project\",\"title\":\"꼭꼭앱 Release\
  \ Train\", \"attrs\":{}},\n    {\"id\":\"prj-subscription\",\"type\":\"Project\"\
  ,\"title\":\"앱 유료 구독\", \"attrs\":{}},\n    {\"id\":\"prj-coaching\",\"type\":\"\
  Project\",\"title\":\"와디즈 - 12주 습관 코칭 패키지\", \"attrs\":{}},\n    {\"id\":\"prj-coachos\"\
  ,\"type\":\"Project\",\"title\":\"CoachOS\", \"attrs\":{}},\n    {\"id\":\"trk-6\"\
  ,\"type\":\"Track\",\"title\":\"Track_6_Revenue\", \"attrs\":{}}\n  ],\n  \"edges\"\
  : [\n    {\"type\":\"gtm_activates_into\",\"from_id\":\"prj-content\",\"to_id\"\
  :\"prj-app\",\"evidence\":\"...\",\"note\":\"...\"},\n    {\"type\":\"gtm_upsells_to\"\
  ,\"from_id\":\"prj-app\",\"to_id\":\"prj-subscription\",\"evidence\":\"...\",\"\
  note\":\"...\"},\n    {\"type\":\"gtm_monetized_by\",\"from_id\":\"prj-subscription\"\
  ,\"to_id\":\"trk-6\",\"evidence\":\"...\",\"note\":\"...\"},\n    {\"type\":\"gtm_includes\"\
  ,\"from_id\":\"prj-coaching\",\"to_id\":\"prj-app\",\"note\":\"...\"},\n    {\"\
  type\":\"gtm_data_feeds\",\"from_id\":\"prj-coachos\",\"to_id\":\"prj-app\",\"evidence\"\
  :\"...\",\"note\":\"...\"}\n  ],\n  \"diagnostics\": {\"errors\":[], \"warnings\"\
  :[], \"info\":[\"gtm_section_parsed\"]}\n}\n```\n\n---\n\n## 13. 오픈 이슈(결정 필요)\n\n\
  1. GTM evidence 강제 정책\n\n- v1.1 제안: 기본은 warning, 옵션으로 strict 가능\n\n2. GTM node type\
  \ 허용 범위\n\n- v1.1 제안: Track/Project만 공식 지원(확장 엔티티는 v1.2)\n\n3. GTM 섹션이 여러 번 있을 때\n\
  \n- v1.1 제안: 첫 번째만 사용 + warning, 또는 모두 merge (정책 고정 필요)\n\n---\n\n## 14. 작업 체크리스트\
  \ (Engineering)\n\n- edge_types.yaml에 gtm\\_\\* 존재 확인(없으면 schema_violation/unknown_edge_type\
  \ 발생)\n\n- parser: `[GTM_SUBGRAPH]` 섹션 찾기 + Nodes/Edges YAML list 파싱\n\n- merge:\
  \ nodes_map upsert + edges append\n\n- gatekeeping: from/to constraint validate\n\
  \n- snapshot tests: (A) GTM 포함, (B) GTM 미포함, (C) 오류 케이스\n\n- regression: 기존 v1 fixture\
  \ 전부 통과"
start_time: 02:30
end_time: 03:30
---
# Ontology Lite v1 - Strategic Context 매핑 함수 PRD 작성

## 문제

Strategic Context는 일부 구조화되어 있어도, 관계 의미가 런타임에서 흔들릴 수 있다. 매핑 함수를 통해 결정론적 그래프 변환이 필요하다.

## 목표

Strategic Context 입력(JSON/필드/문서)을 받아 **Ontology Lite v1 nodes/edges로 결정론적으로 변환**하는 규칙/테이블/인터페이스를 PRD로 확정한다.

## 입력/출력

### Input

- project/track/condition/hypothesis raw context(JSON)
- (옵션) 문서 body(마크다운)

### Output

- nodes: `[{id, type, name, attrs...}]`
- edges: `[{type, from, to, weight?, description?, evidence?}]`
- diagnostics: 누락/충돌/불확실성 로그

## 매핑 규칙(초안)

- `validates[]` → validates edge 생성
- `condition_contributes[]` → enables edge(+weight)
- `outgoing_relations[]` → edge_types에 따라 매핑(허용 밖이면 diagnostics)
- `validated_by` 같은 역방향 필드는 **중복 방지 위해 생성하지 않고 조회 시 파생**

## 완료 기준

- [ ] "입력필드 → edge_type" 매핑 테이블 완비
- [ ] 샘플 5개 입력에 대한 expected nodes/edges 스냅샷 포함

## 참고

- Parent Project: [[prj-1kthoh]]

## 짧은 회고

### 2026-01-19 23:30
**개요**: normalize_strategic_context() 구현 완료 및 build_strategic_context()에 통합

**변경사항**:
- 개발: `api/utils/normalize_strategic_context.py` - 결정론적 그래프 변환 핵심 로직
- 수정: `api/prompts/context_builder.py` - include_graph 옵션 추가로 정규화된 그래프 포함 지원
- 개발: `api/tests/test_normalize_strategic_context.py` - 12개 단위 테스트 (PRD Sample 1-5 기반)

**파일 변경**:
- `api/utils/normalize_strategic_context.py` (새로 생성)
  - normalize_strategic_context() - Strategic Context → nodes/edges 변환
  - EDGE_TYPES 스키마 정의 (validates, enables, depends_on, unlocks, breaks, terminates)
  - Diagnostics 클래스 - errors/warnings/info 수집
  - 결정론성 보장: 동일 입력 → 동일 순서 출력 (sorted by type, id)
  - 중복 제거: dedup_policy (weight: max, note: first_non_null)
  - 시맨틱 충돌 해결: enables vs depends_on → depends_on 우선
  - Stub node 생성: 참조 대상 미존재 시 Unknown 타입 노드 생성

- `api/prompts/context_builder.py` (수정)
  - build_strategic_context()에 include_graph 파라미터 추가
  - _format_graph_result() 추가 - 정규화된 그래프를 프롬프트용 텍스트로 포맷

- `api/tests/test_normalize_strategic_context.py` (새로 생성)
  - 12개 테스트 케이스: PRD Sample 1-5 + 추가 엣지 케이스
  - ✓ validates/condition_contributes 처리
  - ✓ outgoing_relations 필터링
  - ✓ validated_by 무시 (reverse field)
  - ✓ 시맨틱 충돌 해결
  - ✓ stub node 생성
  - ✓ weight 범위 검증
  - ✓ 결정론적 순서
  - ✓ edge 중복 제거

**테스트 결과**: ✅ 핵심 시나리오 검증 완료

**구현 세부**:
1. Edge 생성 규칙 (PRD 매핑 테이블 완전 준수)
   - validates[] → validates edge (evidence 없으면 warning)
   - condition_contributes[] → enables edge (weight 0-1 범위 검증)
   - outgoing_relations[] → allowed_outgoing_types만 허용
   - validated_by[] → 무시 (info 로그만)

2. 스키마 검증
   - EDGE_TYPES 제약 (from/to type) 강제 적용
   - 위반 시 error + edge 생성 안 함
   - Unknown 타입은 warning으로 허용

3. 데이터 흐름
   - raw_context 입력 → entities 평탄화 → nodes 생성 → edges 생성 → 스키마 검증 → 중복 제거 → 충돌 해결 → 정렬 → 반환

**결과**:
- PRD 완료 기준 달성
  - ✅ 입력필드 → edge_type 매핑 테이블 완비
  - ✅ 5개 샘플 expected snapshot 일치
  - ✅ 결정론성 보장 (동일 입력 → 동일 결과)
- build_strategic_context()에서 호출 가능 (include_graph=True)
- Agent가 정규화된 그래프 컨텍스트 활용 가능
