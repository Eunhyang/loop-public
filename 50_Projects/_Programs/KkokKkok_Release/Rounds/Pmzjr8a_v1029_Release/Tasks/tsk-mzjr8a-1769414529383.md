---
entity_type: Task
entity_id: tsk-mzjr8a-1769414529383
entity_name: Recovery - ILOS ë°ì´í„° ë ˆì´ì–´ êµ¬í˜„
created: '2026-01-26'
updated: '2026-01-27'
status: todo
project_id: prj-mzjr8a
parent_id: prj-mzjr8a
assignee: ê¹€ì€í–¥
priority: medium
tags: []
type: dev
aliases:
- tsk-mzjr8a-1769414529383
start_date: '2026-01-27'
due: '2026-01-27'
start_time: '16:00'
end_time: '17:00'
---
# Recovery - ILOS ë°ì´í„° ë ˆì´ì–´ êµ¬í˜„

## ì„¤ëª…

Recovery Routine + Resetì„ **ILOS ì˜¨í†¨ë¡œì§€ ê¸°ë°˜**ìœ¼ë¡œ í”„ë¡œë•ì…˜ì— í†µí•©í•˜ëŠ” ë°ì´í„° ë ˆì´ì–´ êµ¬í˜„.

**í•µì‹¬ ì„¤ê³„ ê²°ì •**:
- âœ… í•˜ë‚˜ì˜ Episodeë¡œ í†µí•© (Recovery Routine + Resetì„ ë‹¨ì¼ ì„¸ì…˜ìœ¼ë¡œ)
- âœ… Full ILOS ì ìš© (Episode + Event ë¶„ë¦¬)
- âœ… OutcomeMeasurement ìë™ ì—°ê²° (2ì‹œê°„ ë‚´ MealDiary ìë™ ë§í¬)

**ILOS ë§¤í•‘ êµ¬ì¡°**:
```
RecoveryEpisode (Episode)
â”œâ”€â”€ uuid, episodeType: 'urge_response'
â”œâ”€â”€ startedAt, completedAt
â”œâ”€â”€ caseType: 'home' | 'mobile'
â”œâ”€â”€ actionType: 'breathing' | 'water_cup'
â”œâ”€â”€ cravingBefore, cravingAfter
â”‚
â”œâ”€â”€ RecoveryEvent[] (Events)
â”‚   â”œâ”€â”€ emotion: {emotion: 'anxious', emoji: 'ğŸ˜°'}
â”‚   â”œâ”€â”€ trigger: {triggers: ['alone', 'stress'], customText: '...'}
â”‚   â”œâ”€â”€ thought: {thoughtText: '...'}
â”‚   â”œâ”€â”€ craving_before: {level: 6.5}
â”‚   â””â”€â”€ craving_after: {level: 3.0}
â”‚
â””â”€â”€ MealDiary (OutcomeMeasurement)
    â””â”€â”€ recoveryEpisodeUuid â†’ ìë™ ì—°ê²°
```

---

## Tech Spec

### Architecture Compliance
- **Parent Project**: prj-mzjr8a (KkokKkok App v1.0.29 - Release)
- **Target**: sosi (Flutter)
- **Pattern**: Local-First + Outbox Pattern (ê¸°ì¡´ ì•„í‚¤í…ì²˜ ì¤€ìˆ˜)
- **State**: flutter_bloc + hydrated_bloc

### File Structure - ì‹ ê·œ ìƒì„±

```
lib/data/models/
â”œâ”€â”€ recovery_episode.dart        # Episode ëª¨ë¸ (freezed)
â”œâ”€â”€ recovery_episode.freezed.dart
â”œâ”€â”€ recovery_episode.g.dart
â”œâ”€â”€ recovery_event.dart          # Event ëª¨ë¸ (freezed)
â”œâ”€â”€ recovery_event.freezed.dart
â””â”€â”€ recovery_event.g.dart

lib/data/local/drift/tables/
â”œâ”€â”€ recovery_episode_table.dart  # Drift í…Œì´ë¸” ì •ì˜
â””â”€â”€ recovery_event_table.dart

lib/data/local/
â”œâ”€â”€ recovery_episode_dao.dart    # Episode CRUD
â””â”€â”€ recovery_event_dao.dart      # Event CRUD

lib/data/repositories/
â””â”€â”€ recovery_repository.dart     # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ í†µí•©

lib/data/remote/
â”œâ”€â”€ firestore_recovery_episode_data_source.dart
â””â”€â”€ firestore_recovery_event_data_source.dart

lib/data/local/database/migrations/
â””â”€â”€ migration_v11.dart           # DB ë§ˆì´ê·¸ë ˆì´ì…˜
```

### File Structure - ìˆ˜ì •

```
lib/data/models/outbox_operation.dart
  â†’ OutboxEntity enumì— recoveryEpisode, recoveryEvent ì¶”ê°€

lib/data/local/drift/app_database.dart
  â†’ í…Œì´ë¸” ë“±ë¡ + schemaVersion 11

lib/data/local/database_helper.dart
  â†’ DAO ì¸ìŠ¤í„´ìŠ¤ ì¶”ê°€

lib/data/services/operation_router.dart
  â†’ Recovery í•¸ë“¤ëŸ¬ ì¶”ê°€

lib/data/services/sync_manager_impl.dart
  â†’ Pull íƒ€ê²Ÿ ì¶”ê°€

lib/data/local/drift/tables/meal_diary_table.dart
  â†’ recoveryEpisodeUuid ì»¬ëŸ¼ ì¶”ê°€

lib/data/local/meal_diary_dao.dart
  â†’ ìë™ì—°ê²° ë©”ì„œë“œ ì¶”ê°€
```

### Implementation Details

#### 1. RecoveryEpisode ëª¨ë¸
```dart
@freezed
class RecoveryEpisode with _$RecoveryEpisode {
  const factory RecoveryEpisode({
    int? id,
    required String uuid,
    required String episodeType,    // 'urge_response' | 'risk_window'
    required String caseType,       // 'home' | 'mobile'
    required DateTime startedAt,
    DateTime? completedAt,
    String? actionType,             // 'breathing' | 'water_cup' | 'awareness'
    int? actionDurationSec,
    @Default(false) bool actionCompleted,
    double? cravingBefore,
    double? cravingAfter,
    String? triggerMealDiaryUuid,
    required DateTime updatedAt,
    DateTime? deletedAt,
  }) = _RecoveryEpisode;
}
```

#### 2. RecoveryEvent ëª¨ë¸
```dart
@freezed
class RecoveryEvent with _$RecoveryEvent {
  const factory RecoveryEvent({
    int? id,
    required String uuid,
    required String episodeUuid,    // FK
    required String eventType,      // 'emotion' | 'trigger' | 'thought' | 'craving_before' | 'craving_after'
    required String payloadJson,    // JSON encoded payload
    required DateTime recordedAt,
    required DateTime updatedAt,
    DateTime? deletedAt,
  }) = _RecoveryEvent;
}
```

#### 3. Drift í…Œì´ë¸”
- `RecoveryEpisodeTable`: uuid(PK), episodeType, caseType, startedAt, completedAt, actionType, actionDurationSec, actionCompleted, cravingBefore, cravingAfter, triggerMealDiaryUuid, updatedAt, deletedAt
- `RecoveryEventTable`: uuid(PK), episodeUuid(FK), eventType, payloadJson, recordedAt, updatedAt, deletedAt

#### 4. RecoveryRepository í•µì‹¬ ë©”ì„œë“œ
```dart
Future<RecoveryEpisode> startSession(String caseType);
Future<void> recordEmotion(String episodeUuid, RecoveryEmotion emotion);
Future<void> recordTriggers(String episodeUuid, List<String> triggers, String? custom);
Future<void> recordThought(String episodeUuid, String text);
Future<void> recordCraving(String episodeUuid, double level, String phase);
Future<void> completeSession(String episodeUuid, {...});
Future<void> linkPendingMealOutcome(String mealDiaryUuid);
```

#### 5. Outcome ìë™ì—°ê²° ë¡œì§
- MealDiary ì €ì¥ ì‹œ 2ì‹œê°„ ë‚´ ì™„ë£Œëœ RecoveryEpisode ê²€ìƒ‰
- ë°œê²¬ ì‹œ `recoveryEpisodeUuid` í•„ë“œ ìë™ ì„¤ì •

### Edge Cases

1. **ì•± ê°•ì œ ì¢…ë£Œ ì‹œ**: Episodeê°€ completedAt ì—†ì´ ë‚¨ìŒ â†’ 24ì‹œê°„ ì´ìƒ ë¯¸ì™„ë£Œ EpisodeëŠ” ìë™ ì •ë¦¬ ëŒ€ìƒ
2. **ë™ì‹œ ì„¸ì…˜ ë°©ì§€**: startSession() í˜¸ì¶œ ì‹œ ì§„í–‰ ì¤‘ì¸ Episode ìˆìœ¼ë©´ ìë™ ì™„ë£Œ ì²˜ë¦¬
3. **ë™ê¸°í™” ì¶©ëŒ**: updatedAt ê¸°ì¤€ last-write-wins (ê¸°ì¡´ íŒ¨í„´ ì¤€ìˆ˜)
4. **Firestore ì¿¼ë¦¬ ìµœì í™”**: episodeUuid ì¸ë±ìŠ¤ í•„ìˆ˜

### Firestore Collection êµ¬ì¡°

```
users/{uid}/
â”œâ”€â”€ recovery_episodes/{uuid}
â”‚   â”œâ”€â”€ uuid, episodeType, caseType
â”‚   â”œâ”€â”€ startedAt, completedAt
â”‚   â”œâ”€â”€ actionType, actionDurationSec, actionCompleted
â”‚   â”œâ”€â”€ cravingBefore, cravingAfter
â”‚   â””â”€â”€ updatedAt, deletedAt, triggerMealDiaryUuid
â”‚
â”œâ”€â”€ recovery_events/{uuid}
â”‚   â”œâ”€â”€ uuid, episodeUuid
â”‚   â”œâ”€â”€ eventType, payloadJson
â”‚   â”œâ”€â”€ recordedAt
â”‚   â””â”€â”€ updatedAt, deletedAt
â”‚
â””â”€â”€ meal_diaries/{uuid}
    â””â”€â”€ recoveryEpisodeUuid (nullable)
```

---

## ì²´í¬ë¦¬ìŠ¤íŠ¸

### Phase 1: ë°ì´í„° ëª¨ë¸ + DB
- [ ] `lib/data/models/recovery_episode.dart` - freezed ëª¨ë¸ ìƒì„±
- [ ] `lib/data/models/recovery_event.dart` - freezed ëª¨ë¸ ìƒì„±
- [ ] `lib/data/local/drift/tables/recovery_episode_table.dart` - Drift í…Œì´ë¸”
- [ ] `lib/data/local/drift/tables/recovery_event_table.dart` - Drift í…Œì´ë¸”
- [ ] `lib/data/local/database/migrations/migration_v11.dart` - ë§ˆì´ê·¸ë ˆì´ì…˜
- [ ] `lib/data/local/drift/app_database.dart` - í…Œì´ë¸” ë“±ë¡ + schemaVersion 11

### Phase 2: DAO
- [ ] `lib/data/local/recovery_episode_dao.dart` - BaseDao í™•ì¥
- [ ] `lib/data/local/recovery_event_dao.dart` - BaseDao í™•ì¥
- [ ] `lib/data/local/database_helper.dart` - DAO ì¸ìŠ¤í„´ìŠ¤ ì¶”ê°€

### Phase 3: Repository
- [ ] `lib/data/repositories/recovery_repository.dart` - ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§

### Phase 4: ë™ê¸°í™”
- [ ] `lib/data/models/outbox_operation.dart` - enum í™•ì¥
- [ ] `lib/data/remote/firestore_recovery_episode_data_source.dart`
- [ ] `lib/data/remote/firestore_recovery_event_data_source.dart`
- [ ] `lib/data/services/operation_router.dart` - í•¸ë“¤ëŸ¬ ì¶”ê°€
- [ ] `lib/data/services/sync_manager_impl.dart` - Pull íƒ€ê²Ÿ ì¶”ê°€

### Phase 5: Outcome ì—°ê²°
- [ ] `lib/data/local/drift/tables/meal_diary_table.dart` - recoveryEpisodeUuid ì¶”ê°€
- [ ] `lib/data/local/meal_diary_dao.dart` - linkRecoveryEpisode() ë©”ì„œë“œ

### Phase 6: ê²€ì¦
- [ ] `flutter pub run build_runner build --delete-conflicting-outputs`
- [ ] `flutter analyze` í†µê³¼
- [ ] ë§ˆì´ê·¸ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸ (ê¸°ì¡´ ë°ì´í„° ë³´ì¡´ í™•ì¸)

---

## ë¶€ë¡ A: ìƒì„¸ ìŠ¤í‚¤ë§ˆ ì •ì˜ (Codex ì´ìŠˆ í•´ê²°)

### A1. Enum ê°’ ì •ì˜

```dart
/// Episode íƒ€ì…
enum RecoveryEpisodeType {
  urgeResponse,   // ì¶©ë™ ëŒ€ì‘ (ì¦‰ê°ì )
  riskWindow,     // ìœ„í—˜ ì‹œê°„ëŒ€ (ì˜ˆë°©ì )
}

/// Case íƒ€ì… (UI íë¦„)
enum RecoveryCaseType {
  home,    // ì§‘ì—ì„œ (ì „ì²´ í”Œë¡œìš°)
  mobile,  // ì´ë™ ì¤‘ (ê°„ì†Œí™” í”Œë¡œìš°)
}

/// Action íƒ€ì…
enum RecoveryActionType {
  breathing,  // í˜¸í¡ ìš´ë™
  waterCup,   // ë¬¼ í•œ ì»µ
  awareness,  // ì•Œì•„ì°¨ë¦¼ (ìƒê° ê¸°ë¡ë§Œ)
}

/// Event íƒ€ì…
enum RecoveryEventType {
  emotion,        // ê°ì • ì„ íƒ
  trigger,        // íŠ¸ë¦¬ê±° ì„ íƒ
  thought,        // ìƒê° ê¸°ë¡
  cravingBefore,  // í–‰ë™ ì „ ê°ˆë§
  cravingAfter,   // í–‰ë™ í›„ ê°ˆë§
}
```

### A2. Drift í…Œì´ë¸” ìƒì„¸ ìŠ¤í‚¤ë§ˆ

```dart
// recovery_episode_table.dart
@DataClassName('RecoveryEpisodeEntry')
class RecoveryEpisodeTable extends Table {
  @override
  String get tableName => 'recovery_episode';

  IntColumn get id => integer().autoIncrement()();
  TextColumn get uuid => text().unique()();                    // NOT NULL, UNIQUE
  TextColumn get episodeType => text()();                      // NOT NULL
  TextColumn get caseType => text()();                         // NOT NULL
  DateTimeColumn get startedAt => dateTime()();                // NOT NULL
  DateTimeColumn get completedAt => dateTime().nullable()();   // nullable
  TextColumn get actionType => text().nullable()();            // nullable
  IntColumn get actionDurationSec => integer().nullable()();   // nullable
  BoolColumn get actionCompleted => boolean().withDefault(const Constant(false))();
  RealColumn get cravingBefore => real().nullable()();         // nullable (0.0~10.0)
  RealColumn get cravingAfter => real().nullable()();          // nullable (0.0~10.0)
  TextColumn get triggerMealDiaryUuid => text().nullable()();  // nullable FK
  DateTimeColumn get updatedAt => dateTime()();                // NOT NULL (syncìš©)
  DateTimeColumn get deletedAt => dateTime().nullable()();     // soft-delete
}

// recovery_event_table.dart
@DataClassName('RecoveryEventEntry')
class RecoveryEventTable extends Table {
  @override
  String get tableName => 'recovery_event';

  IntColumn get id => integer().autoIncrement()();
  TextColumn get uuid => text().unique()();                    // NOT NULL, UNIQUE
  TextColumn get episodeUuid => text()();                      // NOT NULL, FK (no cascade)
  TextColumn get eventType => text()();                        // NOT NULL
  TextColumn get payloadJson => text()();                      // NOT NULL, JSON string
  DateTimeColumn get recordedAt => dateTime()();               // NOT NULL
  DateTimeColumn get updatedAt => dateTime()();                // NOT NULL (syncìš©)
  DateTimeColumn get deletedAt => dateTime().nullable()();     // soft-delete
}
```

**ì¸ë±ìŠ¤ ì •ì˜** (migration_v11.dartì—ì„œ ìƒì„±):
- `recovery_episode`: `uuid` (UNIQUE), `updatedAt` (ë™ê¸°í™” ì¿¼ë¦¬)
- `recovery_event`: `uuid` (UNIQUE), `episodeUuid` (FK ì¡°íšŒ), `episodeUuid + updatedAt` (ë³µí•©)

**FK ì •ì±…**: No CASCADE - Episode ì‚­ì œ ì‹œ Eventë„ ëª…ì‹œì  soft-delete ì²˜ë¦¬

### A3. Outbox í”Œë¡œìš° ìƒì„¸

```dart
// outbox_operation.dart ìˆ˜ì •
enum OutboxEntity {
  diary,
  routine,
  routineTemplate,
  profile,
  routineMealDiaryLink,
  routineInstance,
  weeklyReport,
  chatMessage,
  recoveryEpisode,  // ğŸ†• ì¶”ê°€
  recoveryEvent,    // ğŸ†• ì¶”ê°€
}

// OutboxActionì€ ê¸°ì¡´ ê·¸ëŒ€ë¡œ ì‚¬ìš©: create, update, delete
```

**Outbox Payload ìŠ¤í‚¤ë§ˆ**:

| Entity | Action | Payload |
|--------|--------|---------|
| recoveryEpisode | create/update | ì „ì²´ í•„ë“œ JSON |
| recoveryEpisode | delete | `{ "uuid": "..." }` |
| recoveryEvent | create/update | ì „ì²´ í•„ë“œ JSON |
| recoveryEvent | delete | `{ "uuid": "..." }` |

**Delete ì •ì±…**: Soft-delete (deletedAt ì„¤ì •) - ê¸°ì¡´ íŒ¨í„´ ì¤€ìˆ˜

### A4. Sync/Pull íƒ€ê²Ÿ ìƒì„¸

```dart
// sync_manager_impl.dart ì¶”ê°€
_SyncPullTarget(
  name: 'recovery_episode',
  fetchUpdated: (s) => recoveryEpisodeDataSource.fetchUpdatedEpisodes(s),
  upsertLocal: (e) async {
    await recoveryEpisodeDao.upsert(e as RecoveryEpisode);
  },
),
_SyncPullTarget(
  name: 'recovery_event',
  fetchUpdated: (s) => recoveryEventDataSource.fetchUpdatedEvents(s),
  upsertLocal: (e) async {
    await recoveryEventDao.upsert(e as RecoveryEvent);
  },
),
```

**ë™ê¸°í™” ìˆœì„œ**:
1. recovery_episode (ë¨¼ì €)
2. recovery_event (ë‚˜ì¤‘ - FK ì˜ì¡´)

**ê³ ì•„ Event ì²˜ë¦¬**:
- Pull ì‹œ episodeUuidê°€ ë¡œì»¬ì— ì—†ìœ¼ë©´ â†’ Event ì €ì¥ ê±´ë„ˆëœ€ (ë‹¤ìŒ Sync ì‹œ Episodeê°€ ì˜¬ ìˆ˜ ìˆìŒ)
- ë˜ëŠ” orphanedEpisodeUuids ë¦¬ìŠ¤íŠ¸ ìœ ì§€ í›„ Episode Pull ì™„ë£Œ í›„ ì¬ì²˜ë¦¬

**ì¶©ëŒ ì •ì±…**: Last-write-wins (updatedAt ê¸°ì¤€)

### A5. ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒì„¸ (v11)

```dart
// database_config.dart
static const int version = 11; // v11 recovery_episode + recovery_event

// migration_v11.dart
Future<void> migrateToV11(Database db) async {
  await db.transaction((txn) async {
    // 1. recovery_episode í…Œì´ë¸” ìƒì„±
    await txn.execute('''
      CREATE TABLE IF NOT EXISTS recovery_episode (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        uuid TEXT NOT NULL UNIQUE,
        episodeType TEXT NOT NULL,
        caseType TEXT NOT NULL,
        startedAt TEXT NOT NULL,
        completedAt TEXT,
        actionType TEXT,
        actionDurationSec INTEGER,
        actionCompleted INTEGER NOT NULL DEFAULT 0,
        cravingBefore REAL,
        cravingAfter REAL,
        triggerMealDiaryUuid TEXT,
        updatedAt TEXT NOT NULL,
        deletedAt TEXT
      )
    ''');

    // 2. recovery_event í…Œì´ë¸” ìƒì„±
    await txn.execute('''
      CREATE TABLE IF NOT EXISTS recovery_event (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        uuid TEXT NOT NULL UNIQUE,
        episodeUuid TEXT NOT NULL,
        eventType TEXT NOT NULL,
        payloadJson TEXT NOT NULL,
        recordedAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL,
        deletedAt TEXT
      )
    ''');

    // 3. ì¸ë±ìŠ¤ ìƒì„±
    await txn.execute('CREATE INDEX IF NOT EXISTS idx_episode_updated ON recovery_episode(updatedAt)');
    await txn.execute('CREATE INDEX IF NOT EXISTS idx_event_episode ON recovery_event(episodeUuid)');
    await txn.execute('CREATE INDEX IF NOT EXISTS idx_event_updated ON recovery_event(updatedAt)');

    // 4. meal_diaryì— recoveryEpisodeUuid ì»¬ëŸ¼ ì¶”ê°€
    final columns = await txn.rawQuery("PRAGMA table_info('meal_diary')");
    final hasColumn = columns.any((c) => c['name'] == 'recoveryEpisodeUuid');
    if (!hasColumn) {
      await txn.execute('ALTER TABLE meal_diary ADD COLUMN recoveryEpisodeUuid TEXT');
    }

    // 5. ê²€ì¦
    await _validateMigration(txn);
  });
}
```

### A6. MealDiary ìë™ì—°ê²° ìƒì„¸

**ê¸°ì¤€ íƒ€ì„ìŠ¤íƒ¬í”„**: `Episode.completedAt`

**ë¡œì§**:
```dart
// meal_diary_dao.dart
Future<void> linkRecoveryEpisodeIfNeeded(String mealDiaryUuid, DateTime mealTime) async {
  // 1. mealTime ê¸°ì¤€ 2ì‹œê°„ ì´ì „ ~ mealTime ì‚¬ì´ì— completedAtì´ ìˆëŠ” Episode ê²€ìƒ‰
  final twoHoursBefore = mealTime.subtract(Duration(hours: 2));

  final episodes = await db.query(
    'recovery_episode',
    where: 'completedAt IS NOT NULL AND completedAt >= ? AND completedAt <= ? AND deletedAt IS NULL',
    whereArgs: [twoHoursBefore.toIso8601String(), mealTime.toIso8601String()],
    orderBy: 'completedAt DESC',
    limit: 1,
  );

  if (episodes.isEmpty) return;

  final episodeUuid = episodes.first['uuid'] as String;

  // 2. MealDiaryì— ì—°ê²° (ì´ë¯¸ ì—°ê²°ëœ ê²½ìš° ë®ì–´ì“°ê¸° ì•ˆ í•¨)
  await db.update(
    'meal_diary',
    {'recoveryEpisodeUuid': episodeUuid, 'updatedAt': DateTime.now().toUtc().toIso8601String()},
    where: 'uuid = ? AND recoveryEpisodeUuid IS NULL',
    whereArgs: [mealDiaryUuid],
  );

  // 3. Outbox ê¸°ë¡ (Firestore ë™ê¸°í™”)
  // ... OutboxOperation ìƒì„±
}
```

**ë‹¤ì¤‘ MealDiary ì²˜ë¦¬**: ê°€ì¥ ìµœê·¼ completedAt Episode 1ê°œë§Œ ì—°ê²°

**Episode ì‚­ì œ ì‹œ**: MealDiaryì˜ recoveryEpisodeUuidë¥¼ NULLë¡œ ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŒ (íˆìŠ¤í† ë¦¬ ë³´ì¡´)

**ì—°ê²° ì‹œì **: MealDiary INSERT/UPDATE í›„ í˜¸ì¶œ

### A7. Repository API ìƒì„¸

```dart
class RecoveryRepository {
  RecoveryRepository({
    required this.episodeDao,
    required this.eventDao,
    required this.outboxDao,
  });

  final RecoveryEpisodeDao episodeDao;
  final RecoveryEventDao eventDao;
  final OutboxDao outboxDao;

  /// ìƒˆ ì„¸ì…˜ ì‹œì‘ - ì§„í–‰ ì¤‘ì¸ Episode ìˆìœ¼ë©´ ìë™ ì™„ë£Œ ì²˜ë¦¬
  Future<RecoveryEpisode> startSession({
    required RecoveryCaseType caseType,
    RecoveryEpisodeType episodeType = RecoveryEpisodeType.urgeResponse,
  }) async {
    // 1. ì§„í–‰ ì¤‘ì¸ Episode ì™„ë£Œ ì²˜ë¦¬
    await _completeIncompleteEpisodes();

    // 2. ìƒˆ Episode ìƒì„±
    final episode = RecoveryEpisode(
      uuid: Uuid().v4(),
      episodeType: episodeType.name,
      caseType: caseType.name,
      startedAt: DateTime.now().toUtc(),
      updatedAt: DateTime.now().toUtc(),
    );

    await episodeDao.upsert(episode);
    await _enqueueOutbox(OutboxEntity.recoveryEpisode, OutboxAction.create, episode);

    return episode;
  }

  /// Event ê¸°ë¡ (ë‚´ë¶€ì ìœ¼ë¡œ Outbox ìë™ ìƒì„±)
  Future<RecoveryEvent> _recordEvent({
    required String episodeUuid,
    required RecoveryEventType eventType,
    required Map<String, dynamic> payload,
  }) async {
    final event = RecoveryEvent(
      uuid: Uuid().v4(),
      episodeUuid: episodeUuid,
      eventType: eventType.name,
      payloadJson: jsonEncode(payload),
      recordedAt: DateTime.now().toUtc(),
      updatedAt: DateTime.now().toUtc(),
    );

    await eventDao.upsert(event);
    await _enqueueOutbox(OutboxEntity.recoveryEvent, OutboxAction.create, event);

    return event;
  }

  /// ê°ì • ê¸°ë¡
  Future<void> recordEmotion(String episodeUuid, String emotion, String emoji) =>
    _recordEvent(
      episodeUuid: episodeUuid,
      eventType: RecoveryEventType.emotion,
      payload: {'emotion': emotion, 'emoji': emoji},
    );

  /// íŠ¸ë¦¬ê±° ê¸°ë¡
  Future<void> recordTriggers(String episodeUuid, List<String> triggers, String? customText) =>
    _recordEvent(
      episodeUuid: episodeUuid,
      eventType: RecoveryEventType.trigger,
      payload: {'triggers': triggers, 'customText': customText},
    );

  /// ìƒê° ê¸°ë¡
  Future<void> recordThought(String episodeUuid, String text) =>
    _recordEvent(
      episodeUuid: episodeUuid,
      eventType: RecoveryEventType.thought,
      payload: {'thoughtText': text},
    );

  /// ê°ˆë§ ë ˆë²¨ ê¸°ë¡
  Future<void> recordCraving(String episodeUuid, double level, String phase) async {
    final eventType = phase == 'before'
      ? RecoveryEventType.cravingBefore
      : RecoveryEventType.cravingAfter;

    await _recordEvent(
      episodeUuid: episodeUuid,
      eventType: eventType,
      payload: {'level': level},
    );

    // Episodeì—ë„ denormalized ì €ì¥ (ì¿¼ë¦¬ í¸ì˜)
    final field = phase == 'before' ? 'cravingBefore' : 'cravingAfter';
    await episodeDao.updateField(episodeUuid, field, level);
  }

  /// ì„¸ì…˜ ì™„ë£Œ
  Future<void> completeSession(
    String episodeUuid, {
    RecoveryActionType? actionType,
    int? actionDurationSec,
    bool actionCompleted = false,
  }) async {
    await episodeDao.complete(
      episodeUuid,
      actionType: actionType?.name,
      actionDurationSec: actionDurationSec,
      actionCompleted: actionCompleted,
    );

    // Outbox update
    final episode = await episodeDao.findByUuid(episodeUuid);
    if (episode != null) {
      await _enqueueOutbox(OutboxEntity.recoveryEpisode, OutboxAction.update, episode);
    }
  }

  /// ìµœê·¼ Episode ì¡°íšŒ (í†µê³„ìš©)
  Future<List<RecoveryEpisode>> getRecentEpisodes({int days = 7}) =>
    episodeDao.fetchRecent(days: days);

  /// Episodeì— ì—°ê²°ëœ Event ì¡°íšŒ
  Future<List<RecoveryEvent>> getEventsForEpisode(String episodeUuid) =>
    eventDao.fetchByEpisodeUuid(episodeUuid);
}
```

### A8. Freezed ì§ë ¬í™” ìƒì„¸

```dart
// recovery_episode.dart
@freezed
class RecoveryEpisode with _$RecoveryEpisode {
  const factory RecoveryEpisode({
    int? id,
    required String uuid,
    required String episodeType,
    required String caseType,
    required DateTime startedAt,
    DateTime? completedAt,
    String? actionType,
    int? actionDurationSec,
    @Default(false) bool actionCompleted,
    double? cravingBefore,
    double? cravingAfter,
    String? triggerMealDiaryUuid,
    required DateTime updatedAt,
    DateTime? deletedAt,
  }) = _RecoveryEpisode;

  /// JSON ì§ë ¬í™” (Firestore/Outboxìš©)
  factory RecoveryEpisode.fromJson(Map<String, dynamic> json) =>
      _$RecoveryEpisodeFromJson(json);
}

// recovery_episode.g.dart (build_runner ìƒì„±)
// DateTimeì€ ISO8601 Stringìœ¼ë¡œ ìë™ ë³€í™˜
```

**DAO toMap/fromEntry ë³€í™˜**:
```dart
Map<String, dynamic> toMap(RecoveryEpisode model) => {
  'id': model.id,
  'uuid': model.uuid,
  'episodeType': model.episodeType,
  'caseType': model.caseType,
  'startedAt': model.startedAt.toIso8601String(),
  'completedAt': model.completedAt?.toIso8601String(),
  // ... ë‚˜ë¨¸ì§€ í•„ë“œ
  'updatedAt': model.updatedAt.toIso8601String(),
  'deletedAt': model.deletedAt?.toIso8601String(),
};

RecoveryEpisode fromEntry(RecoveryEpisodeEntry e) => RecoveryEpisode(
  id: e.id,
  uuid: e.uuid,
  episodeType: e.episodeType,
  caseType: e.caseType,
  startedAt: e.startedAt,
  completedAt: e.completedAt,
  // ... DriftëŠ” DateTime ìë™ ì²˜ë¦¬
  updatedAt: e.updatedAt,
  deletedAt: e.deletedAt,
);
```

---

## ì°¸ê³ 

- **BaseDao íŒ¨í„´**: `lib/data/local/base_dao.dart`
- **Drift ë§ˆì´ê·¸ë ˆì´ì…˜ ì˜ˆì‹œ**: `lib/data/local/database/migrations/migration_v10.dart`
- **OutboxEntity ì˜ˆì‹œ**: `lib/data/models/outbox_operation.dart`
- **OperationRouter ì˜ˆì‹œ**: `lib/data/services/operation_router.dart`
- **SyncManager ì˜ˆì‹œ**: `lib/data/services/sync_manager_impl.dart`
- **DatabaseConfig**: `lib/data/local/database_config.dart` (í˜„ì¬ v10)

---

## ì§§ì€ íšŒê³ 
