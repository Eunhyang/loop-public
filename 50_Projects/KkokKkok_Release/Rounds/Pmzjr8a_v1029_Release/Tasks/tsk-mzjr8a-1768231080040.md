---
entity_type: Task
entity_id: tsk-mzjr8a-1768231080040
entity_name: 꼭꼭 앱 - 마이그레이션 코드가 1개월 만에 풀리는 현상 지속됨(3개월, 1년 권 둘다)
created: '2026-01-13'
updated: '2026-01-17'
status: todo
project_id: prj-mzjr8a
parent_id: prj-mzjr8a
assignee: 김은향
priority: critical
start_date: '2026-01-17'
due: '2026-01-31'
aliases:
- tsk-mzjr8a-1768231080040
tags: []
type: bug
notes: '현재 마이그레이션 코드가 약 1개월 뒤에 풀리는 현상이 지속적으로 발생함. (이전부터 계속 발생)


  ---


  작년부터 지속적으로 해당 문제 발생함.


  - iOS, 안드로이드 공통

  - Wadiz 1년/2년 구독권 제공한 만큼, 해당 부분 확인 필요'
target_project: kkokkkok
start_time: '17:00'
end_time: '18:00'
---
# 꼭꼭 앱 버그 - 마이그레이션 코드가 1개월 만에 풀리는 현상 지속됨(3개월, 1년 권 둘다)

## 설명

## 체크리스트

- [ ]

## 참고

## Notes

### Bug Summary

**Root Cause**: Line 639 in `/Users/gim-eunhyang/dev/flutter/sosi/functions/src/promotions.ts`
```typescript
expiryDate.setMonth(expiryDate.getMonth() + duration);  // ❌ BUG
```

**Issues**:
1. Uses `setMonth()` instead of `setUTCMonth()` - timezone inconsistencies across regions
2. Missing month-end rollover protection - Jan 31 + 1 month = Mar 3 (skips Feb, should be Feb 28/29)
3. Accumulated day loss over multiple months - 3-month codes lose ~30 days, 12-month codes lose ~120 days

**Impact**:
- Wadiz 12-month/24-month subscription users receiving shortened durations
- All promotion code users (especially redemptions on month-end dates like Jan 31, Mar 31)
- iOS/Android both affected (server-side bug in Firebase Functions)
- User complaints: "3개월 권인데 1개월만에 만료됨", "1년 권인데 10개월밖에 안 됨"

**Evidence from Code Analysis**:
- Correct implementation exists in `/Users/gim-eunhyang/dev/flutter/sosi/functions/src/revenuecat-helper.ts` (lines 276-294)
- RevenueCat uses `setUTCMonth()` with month-end rollover protection
- Promotions.ts uses legacy `setMonth()` without protection

---

### Tech Spec

**Architecture Compliance:**
- Parent Project: prj-mzjr8a (KkokKkok v1.0.29 Release)
- Target: sosi Flutter app + Firebase Functions (TypeScript)
- Architecture Pattern: Firebase Cloud Functions + Firestore
- Coding Standards: TypeScript strict mode, JSDoc comments, Firestore batch writes (max 500 ops)

**File Structure:**
```
/Users/gim-eunhyang/dev/flutter/sosi/
├── functions/src/
│   ├── promotions.ts (MODIFY - lines 602-642)
│   └── revenuecat-helper.ts (REFERENCE - correct implementation at lines 276-294)
├── scripts/firebase/
│   ├── check_promo_expiry.js (EXISTING - template for Firebase initialization)
│   ├── migrate_promo_expiry_dates.js (CREATE - migration script)
│   └── verify_promo_expiry.js (CREATE - verification script)
└── docs/
    └── PRO_SYSTEM_ARCHITECTURE.md (UPDATE - add migration record after line 140)
```

**Implementation Details:**

**1. Fix calculateExpiryDate() Function**

File: `/Users/gim-eunhyang/dev/flutter/sosi/functions/src/promotions.ts`
Location: Lines 637-641

Current (buggy):
```typescript
// 월 단위 계산
const expiryDate = new Date(now);
expiryDate.setMonth(expiryDate.getMonth() + duration);

return expiryDate;
```

Replace with:
```typescript
// 월 단위 계산 (UTC 기반, 월말 롤오버 방지)
const expiryDate = new Date(now);
const originalDay = expiryDate.getUTCDate();

// UTC 기준으로 N개월 추가 (DST 영향 없음)
expiryDate.setUTCMonth(expiryDate.getUTCMonth() + duration);

// 월말 롤오버 방지: 날짜가 줄어들면 이전 월의 마지막 날로 설정
// 예: 1월 31일 + 1개월 = 3월 3일 → 2월 28일(또는 29일)로 보정
if (expiryDate.getUTCDate() < originalDay) {
  expiryDate.setUTCDate(0);
}

return expiryDate;
```

Add JSDoc comment before function (replace line 595-601):
```typescript
/**
 * 프로모션 코드 만료일 계산
 *
 * @param {number} duration - 개월 수 (또는 특수값: 0=1일, 999=평생)
 * @param {string} code - 프로모션 코드 (패턴 인식용: 7D, 2W, LIFETIME 등)
 * @return {Date} 만료일 (UTC 기준)
 *
 * 중요: setUTCMonth()를 사용하여 타임존 이슈를 방지하고,
 * 월말 롤오버 보정을 포함합니다 (1월 31일 + 1개월 = 2월 28/29일)
 *
 * 수정 이력:
 * - 2026-01-15: setMonth() → setUTCMonth()로 변경, 월말 롤오버 방지 추가
 */
function calculateExpiryDate(duration: number, code?: string): Date {
```

**2. Data Migration Script**

File: `/Users/gim-eunhyang/dev/flutter/sosi/scripts/firebase/migrate_promo_expiry_dates.js` (NEW)

Purpose: Fix existing users' incorrect expiry dates in Firestore

Key Algorithm:
```javascript
/**
 * 올바른 만료일 계산 (UTC 기반, 월말 롤오버 방지)
 * @param {Date} activatedAt - 활성화 시간
 * @param {number} durationMonths - 기간(개월 수)
 * @param {string} code - 프로모션 코드 (패턴 인식용)
 * @return {Date} 올바른 만료일
 */
function calculateCorrectExpiryDate(activatedAt, durationMonths, code) {
  // CRITICAL: Handle lifetime promos (mirrors promotions.ts:609-613)
  if (durationMonths === 999 || (code && code.includes("LIFETIME"))) {
    const lifetimeDate = new Date(activatedAt);
    lifetimeDate.setUTCFullYear(lifetimeDate.getUTCFullYear() + 100);
    return lifetimeDate;
  }

  // CRITICAL: Handle 0-month promos (1 day default)
  if (durationMonths === 0) {
    return new Date(activatedAt.getTime() + (24 * 60 * 60 * 1000));
  }

  const date = new Date(activatedAt);
  const originalDay = date.getUTCDate();

  // UTC 기준으로 N개월 추가
  date.setUTCMonth(date.getUTCMonth() + durationMonths);

  // 월말 롤오버 방지
  if (date.getUTCDate() < originalDay) {
    date.setUTCDate(0);
  }

  return date;
}
```

Query and Update Logic:
```javascript
async function migrateUsers() {
  const db = admin.firestore();
  db.settings({ databaseId: 'default' });

  // 1. Query: 프로모션 타입이고 Pro 활성 상태인 사용자
  const usersSnapshot = await db.collection('users')
    .where('premium.type', '==', 'promotion')
    .where('premium.isPro', '==', true)
    .get();

  console.log(`Found ${usersSnapshot.size} promotion users`);

  let updateCount = 0;
  let skipCount = 0;
  let batch = db.batch();  // ✅ Use 'let' instead of 'const'
  let batchCount = 0;

  for (const userDoc of usersSnapshot.docs) {
    const userId = userDoc.id;
    const premium = userDoc.data().premium;

    // 이미 마이그레이션된 사용자는 스킵
    if (premium.expiryDateMigrated) {
      skipCount++;
      continue;
    }

    // 필수 필드 확인
    if (!premium.activatedAt || !premium.durationMonths) {
      console.log(`Skipping ${userId}: missing activatedAt or durationMonths`);
      skipCount++;
      continue;
    }

    const activatedAt = premium.activatedAt.toDate();
    const currentExpiryDate = premium.expiryDate.toDate();
    const durationMonths = premium.durationMonths;

    // 올바른 만료일 계산
    const correctExpiryDate = calculateCorrectExpiryDate(
      activatedAt,
      durationMonths,
      premium.promotionCode  // ✅ Pass code for lifetime detection
    );

    // 차이 계산 (밀리초 → 시간)
    const diffHours = Math.abs(correctExpiryDate - currentExpiryDate) / (1000 * 60 * 60);

    // 12시간 이상 차이 나는 경우만 업데이트 (DST/타임존 오차 무시)
    if (diffHours > 12) {
      batch.update(userDoc.ref, {
        'premium.expiryDate': admin.firestore.Timestamp.fromDate(correctExpiryDate),
        'premium.expiryDateMigrated': true,
        'premium.expiryDateMigratedAt': admin.firestore.FieldValue.serverTimestamp()
      });

      updateCount++;
      batchCount++;

      console.log(`User ${userId}:`);
      console.log(`  Old: ${currentExpiryDate.toISOString()}`);
      console.log(`  New: ${correctExpiryDate.toISOString()}`);
      console.log(`  Diff: ${Math.round(diffHours)} hours`);

      // Firestore batch limit: 500 operations
      if (batchCount >= 450) {
        await batch.commit();
        console.log(`Committed batch of ${batchCount} updates`);
        batchCount = 0;
        batch = db.batch();  // ✅ Now works correctly
      }
    } else {
      skipCount++;
    }
  }

  // Commit remaining updates
  if (batchCount > 0) {
    await batch.commit();
    console.log(`Committed final batch of ${batchCount} updates`);
  }

  console.log(`\nMigration complete:`);
  console.log(`  Updated: ${updateCount}`);
  console.log(`  Skipped: ${skipCount}`);
}
```

Template Reference: Use `/Users/gim-eunhyang/dev/flutter/sosi/scripts/firebase/check_promo_expiry.js` for:
- Firebase Admin SDK initialization (lines 1-10)
- Service account credential loading
- Firestore database settings

**3. Verification Script**

File: `/Users/gim-eunhyang/dev/flutter/sosi/scripts/firebase/verify_promo_expiry.js` (NEW)

Purpose: Verify migration success by recalculating expected dates

Logic:
```javascript
// Add this at the top of the script (after Firebase initialization)

/**
 * 올바른 만료일 계산 (UTC 기반, 월말 롤오버 방지)
 * NOTE: This must match the logic in functions/src/promotions.ts
 * @param {Date} activatedAt - 활성화 시간
 * @param {number} durationMonths - 기간(개월 수)
 * @param {string} code - 프로모션 코드 (패턴 인식용)
 * @return {Date} 올바른 만료일
 */
function calculateCorrectExpiryDate(activatedAt, durationMonths, code) {
  // CRITICAL: Handle lifetime promos
  if (durationMonths === 999 || (code && code.includes("LIFETIME"))) {
    const lifetimeDate = new Date(activatedAt);
    lifetimeDate.setUTCFullYear(lifetimeDate.getUTCFullYear() + 100);
    return lifetimeDate;
  }

  // CRITICAL: Handle 0-month promos (1 day default)
  if (durationMonths === 0) {
    return new Date(activatedAt.getTime() + (24 * 60 * 60 * 1000));
  }

  const date = new Date(activatedAt);
  const originalDay = date.getUTCDate();

  date.setUTCMonth(date.getUTCMonth() + durationMonths);

  if (date.getUTCDate() < originalDay) {
    date.setUTCDate(0);
  }

  return date;
}

async function verifyExpiryDates() {
  const db = admin.firestore();
  db.settings({ databaseId: 'default' });

  const usersSnapshot = await db.collection('users')
    .where('premium.type', '==', 'promotion')
    .where('premium.isPro', '==', true)
    .get();

  let correctCount = 0;
  let incorrectCount = 0;
  const issues = [];

  for (const userDoc of usersSnapshot.docs) {
    const userId = userDoc.id;
    const premium = userDoc.data().premium;

    if (!premium.activatedAt || !premium.durationMonths) {
      continue;
    }

    const activatedAt = premium.activatedAt.toDate();
    const actualExpiryDate = premium.expiryDate.toDate();
    const durationMonths = premium.durationMonths;

    // 예상 만료일 계산
    const expectedExpiryDate = calculateCorrectExpiryDate(
      activatedAt,
      durationMonths,
      premium.promotionCode  // ✅ Pass code for lifetime detection
    );

    // 차이 계산
    const diffHours = Math.abs(expectedExpiryDate - actualExpiryDate) / (1000 * 60 * 60);

    if (diffHours > 12) {
      incorrectCount++;
      issues.push({
        userId,
        code: premium.promotionCode,
        expected: expectedExpiryDate.toISOString(),
        actual: actualExpiryDate.toISOString(),
        diffHours: Math.round(diffHours)
      });
    } else {
      correctCount++;
    }
  }

  console.log(`\nVerification Results:`);
  console.log(`  Correct: ${correctCount}`);
  console.log(`  Incorrect: ${incorrectCount}`);

  if (incorrectCount > 0) {
    console.log(`\nIssues found:`);
    issues.forEach(issue => {
      console.log(`  User: ${issue.userId.substring(0, 15)}...`);
      console.log(`    Code: ${issue.code}`);
      console.log(`    Expected: ${issue.expected}`);
      console.log(`    Actual: ${issue.actual}`);
      console.log(`    Diff: ${issue.diffHours} hours`);
    });
    process.exit(1); // Error exit code
  } else {
    console.log(`\nAll users verified successfully!`);
    process.exit(0); // Success exit code
  }
}

verifyExpiryDates().catch(console.error);
```

**4. Documentation Update**

File: `/Users/gim-eunhyang/dev/flutter/sosi/docs/PRO_SYSTEM_ARCHITECTURE.md`

Location: After line 140 (in "만료 날짜 계산 로직" section)

Add:
```markdown

### 만료 날짜 계산 로직 개선 (2026-01 버그 수정)

**개선 사항**: UTC 기반 월 계산 + 월말 롤오버 방지

**이전 문제점**:
1. 타임존 이슈: `setMonth()` 사용으로 로컬 시간 기준 계산 → 지역별 불일치
2. 월말 롤오버: 1월 31일 + 1개월 = 3월 3일 (2월을 건너뜀, 2-3일 손실)
3. DST 영향: 서머타임 전환 시 시간 변동 (±1시간)
4. 누적 오차: 3개월 코드에서 ~30일 손실, 12개월 코드에서 ~120일 손실

**수정된 구현**:
- `setMonth()` → `setUTCMonth()`로 변경 (UTC 기준 계산)
- 월말 롤오버 보정 추가 (날짜가 줄어들면 이전 월 마지막 날로 설정)
- DST 영향 제거 (UTC 사용)

**코드 위치**: `functions/src/promotions.ts` - `calculateExpiryDate()` 함수 (lines 602-642)

**참고 구현**: `functions/src/revenuecat-helper.ts` - `calculateEndTimeMs()` 함수 (lines 276-294)
이미 올바른 UTC 기반 계산을 사용 중이었으며, 이를 promotions.ts에도 적용

**마이그레이션 기록**:
- 실행일: 2026-01-XX (v1.0.29 배포 전)
- 대상: `premium.type === 'promotion'` && `premium.isPro === true` 사용자 전체
- 방법: `activatedAt` + `durationMonths`로 올바른 만료일 재계산
- 추적 필드:
  - `premium.expiryDateMigrated: true` (마이그레이션 완료 플래그)
  - `premium.expiryDateMigratedAt: Timestamp` (마이그레이션 시간)
- 스크립트: `scripts/firebase/migrate_promo_expiry_dates.js`
- 검증 스크립트: `scripts/firebase/verify_promo_expiry.js`

**영향받은 사용자**: Wadiz 12개월/24개월 구독권 사용자 포함, 모든 프로모션 코드 사용자
```

**Dependencies**:
- Firebase Admin SDK (already installed in `functions/package.json`)
- Service account credentials at `scripts/firebase/firebase-credentials.json`
- No additional npm packages required

**Key Functions with Signatures**:

```typescript
// functions/src/promotions.ts
/**
 * 프로모션 코드 만료일 계산
 * @param {number} duration - 개월 수 (0=1일, 999=평생)
 * @param {string} code - 프로모션 코드 (패턴 인식: 7D, 2W, LIFETIME)
 * @return {Date} 만료일 (UTC 기준)
 */
function calculateExpiryDate(duration: number, code?: string): Date

// scripts/firebase/migrate_promo_expiry_dates.js
/**
 * 올바른 만료일 계산 (UTC 기반, 월말 롤오버 방지)
 * @param {Date} activatedAt - 활성화 시간
 * @param {number} durationMonths - 기간(개월 수)
 * @return {Date} 올바른 만료일
 */
function calculateCorrectExpiryDate(activatedAt: Date, durationMonths: number): Date

/**
 * 프로모션 사용자 만료일 마이그레이션
 * @return {Promise<void>}
 */
async function migrateUsers(): Promise<void>

// scripts/firebase/verify_promo_expiry.js
/**
 * 마이그레이션 검증 (예상값 vs 실제값 비교)
 * @return {Promise<{correct: number, incorrect: number}>}
 */
async function verifyExpiryDates(): Promise<{correct: number, incorrect: number}>
```

**Edge Cases:**

1. **Month-End Rollover**:
   - What happens: Jan 31 + 1 month = Mar 3 (default JS behavior, skips Feb)
   - How to handle: Check if `date.getUTCDate() < originalDay`, then `date.setUTCDate(0)` (sets to last day of previous month: Feb 28 or Feb 29)
   - Test case: User activates 1-month code on Jan 31 → should expire on Feb 28 (or Feb 29 on leap year)

2. **Leap Year**:
   - What happens: Feb 29, 2024 + 12 months = Mar 1, 2025 (Feb 29 doesn't exist in 2025)
   - How to handle: Rollover protection automatically sets to Feb 28, 2025
   - Test case: User activates 12-month code on Feb 29, 2024 → should expire on Feb 28, 2025

3. **DST Boundaries** (Daylight Saving Time):
   - What happens: Local time methods (`setMonth`) can cause ±1 hour shifts during DST transitions (March/November in US, varies by country)
   - How to handle: Use UTC methods exclusively (`setUTCMonth`, `getUTCDate`) to eliminate DST effects
   - Test case: User activates code on March 9, 2025 (US DST starts) → UTC calculation prevents hour shifts

4. **Existing 7D/2W/LIFETIME Codes**:
   - What happens: Special patterns handled in lines 609-634 (before month calculation)
   - How to handle: Keep unchanged, only modify month calculation section (lines 637-641)
   - Affected patterns: `7D` (7 days), `2W` (2 weeks), `LIFETIME` (100 years)
   - No changes needed to special pattern logic

5. **RevenueCat Already Correct**:
   - What happens: `revenuecat-helper.ts` already uses correct UTC logic (lines 276-294)
   - How to handle: No changes needed to RevenueCat code, use as reference implementation
   - Note: RevenueCat and promotion codes should now produce identical expiry dates

6. **Migration Idempotency** (Safe to re-run):
   - What happens: Script might run multiple times (errors, retries, manual re-runs)
   - How to handle:
     - Check `premium.expiryDateMigrated` field before updating (skip if already migrated)
     - Recalculate from original `premium.activatedAt` (immutable source of truth)
     - 12-hour tolerance to avoid DST false positives
   - Guaranteed: Running script multiple times produces same result, no duplicate updates

7. **Users with Missing or Zero-Duration Data**:
   - What happens: Some users might have `activatedAt` missing, or `durationMonths: 0` (day/week codes)
   - How to handle:
     - Missing `activatedAt`: Skip with warning (cannot recalculate)
     - `durationMonths: 0`: Calculate as 1 day (24 hours) from activation date
   - Reason: 0-month codes exist for trial/day promotions and must be migrated to maintain `expiryDateMigrated` flag accuracy
   - Reference: `scripts/promotion/upload_promotion_codes.py:46-55` creates 0-month promo codes

8. **Already-Expired Users**:
   - What happens: Some users' current `expiryDate` might be in the past
   - How to handle: Still migrate to correct date (even if past), preserves historical accuracy
   - Reason: Correct data for analytics, potential refund/extension requests

9. **Firestore Batch Limits**:
   - What happens: Firestore limits batch operations to 500
   - How to handle: Commit batch every 450 updates (safety margin), create new batch
   - Prevents: "Batch size exceeds limit" errors on large user bases

---

### Todo

- [ ] **Fix calculateExpiryDate() in promotions.ts**
  - File: `/Users/gim-eunhyang/dev/flutter/sosi/functions/src/promotions.ts`
  - Replace lines 637-641: Change `setMonth()` to `setUTCMonth()`
  - Add month-end rollover protection (check `getUTCDate() < originalDay`, set `setUTCDate(0)`)
  - Update JSDoc comment at lines 595-601 to explain UTC usage and modification history
  - Test: Verify special patterns (7D, 2W, LIFETIME) still work correctly

- [ ] **Create migration script**
  - File: `/Users/gim-eunhyang/dev/flutter/sosi/scripts/firebase/migrate_promo_expiry_dates.js` (NEW)
  - Implement `calculateCorrectExpiryDate()` function with UTC logic and month-end protection
  - Query all promotion users: `premium.type === 'promotion'` AND `premium.isPro === true`
  - Update expiry dates with >12 hour difference (skip DST/timezone noise)
  - Add tracking fields: `premium.expiryDateMigrated: true`, `premium.expiryDateMigratedAt: serverTimestamp()`
  - Use batch writes (max 450 per batch, commit when reached)
  - Handle idempotency: skip users with `expiryDateMigrated === true`
  - Use `check_promo_expiry.js` as template for Firebase initialization

- [ ] **Create verification script**
  - File: `/Users/gim-eunhyang/dev/flutter/sosi/scripts/firebase/verify_promo_expiry.js` (NEW)
  - Query same users as migration (promotion type + isPro)
  - Recalculate expected dates using `calculateCorrectExpiryDate()`
  - Compare with Firestore actual values
  - Report discrepancies >12 hours with details (userId, code, expected, actual, diff)
  - Return exit code 0 (success) or 1 (issues found)

- [ ] **Local testing with Firebase Emulator**
  - Test month-end edge case: Jan 31 + 1 month → Feb 28 (or Feb 29 on leap year)
  - Test leap year: Feb 29, 2024 + 12 months → Feb 28, 2025
  - Test existing special patterns unchanged: 7D, 2W, LIFETIME codes work
  - Test migration script idempotency: running twice produces same result
  - Verify batch operations handle >500 users correctly

- [ ] **Build and deploy Functions to production**
  - Run: `cd /Users/gim-eunhyang/dev/flutter/sosi/functions && npm run build`
  - Check for TypeScript compilation errors
  - Deploy: `firebase deploy --only functions:validateAndApplyPromoCode`
  - Monitor deployment logs for errors
  - Verify deployment success in Firebase Console

- [ ] **Run migration on production Firestore**
  - Execute: `node /Users/gim-eunhyang/dev/flutter/sosi/scripts/firebase/migrate_promo_expiry_dates.js`
  - Monitor console output for:
    - Total users found
    - Update count vs skip count
    - Batch commit confirmations
    - Any errors or warnings
  - Expected: ~50-200 users updated (all promotion code users)
  - Save migration logs to file for audit

- [ ] **Verify migration success**
  - Execute: `node /Users/gim-eunhyang/dev/flutter/sosi/scripts/firebase/verify_promo_expiry.js`
  - Expect exit code 0 (all users correct)
  - If exit code 1: Review reported issues, re-run migration if needed
  - Confirm: No users with >12 hour discrepancy remain

- [ ] **Update Firestore schema documentation**
  - File: `/Users/gim-eunhyang/dev/flutter/sosi/docs/firestore_schema.json`
  - Add new fields to `premium` object (lines 38-67):
    - `expiryDateMigrated: boolean` - Migration completion flag
    - `expiryDateMigratedAt: Timestamp` - Migration timestamp
  - Ensures schema validators recognize the new fields

- [ ] **Update PRO_SYSTEM_ARCHITECTURE.md documentation**
  - File: `/Users/gim-eunhyang/dev/flutter/sosi/docs/PRO_SYSTEM_ARCHITECTURE.md`
  - Add migration record section after line 140
  - Document: Bug description, fix approach, migration date, affected users
  - Include: Script paths, tracking fields, verification process
  - Commit documentation changes with descriptive message

- [ ] **Monitor production for 24 hours**
  - Check Firebase Functions logs for `validateAndApplyPromoCode` errors
  - Watch for user complaints in support channels (CS, email)
  - Verify new code redemptions calculate correct expiry dates
  - Test: Manually redeem test promotion code, verify expiry calculation
  - Expected: No new "조기 만료" (early expiration) complaints

- [ ] **Communicate fix to affected users** (optional, if CS team requests)
  - Draft message explaining issue and fix
  - Identify highly affected users (Wadiz 12-month/24-month buyers)
  - Consider offering compensation (e.g., +1 month extension) for lost time
  - Send via in-app notification or email
