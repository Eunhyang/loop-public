---
entity_type: Task
entity_id: tsk-1kthoh-1768748985191
entity_name: Ontology Lite v1 - Strategic Context 매핑 함수 생성
created: '2026-01-19'
updated: '2026-01-19'
status: todo
project_id: prj-1kthoh
parent_id: prj-1kthoh
assignee: 김은향
priority: high
start_date: '2026-01-18'
due: '2026-01-19'
aliases:
- tsk-1kthoh-1768748985191
tags: []
type: dev
_path: 50_Projects/2025/P1_Ontology_Vault_Ontology_Lite_v1/Tasks/tsk-1kthoh-1768748072863.md
_body: '# Ontology Lite v1 - Strategic Context 매핑 함수 PRD 작성


  ## 문제


  Strategic Context는 일부 구조화되어 있어도, 관계 의미가 런타임에서 흔들릴 수 있다. 매핑 함수를 통해 결정론적 그래프 변환이 필요하다.


  ## 목표


  Strategic Context 입력(JSON/필드/문서)을 받아 **Ontology Lite v1 nodes/edges로 결정론적으로 변환**하는
  규칙/테이블/인터페이스를 PRD로 확정한다.


  ## 입력/출력


  ### Input


  - project/track/condition/hypothesis raw context(JSON)

  - (옵션) 문서 body(마크다운)


  ### Output


  - nodes: `[{id, type, name, attrs...}]`

  - edges: `[{type, from, to, weight?, description?, evidence?}]`

  - diagnostics: 누락/충돌/불확실성 로그


  ## 매핑 규칙(초안)


  - `validates[]` → validates edge 생성

  - `condition_contributes[]` → enables edge(+weight)

  - `outgoing_relations[]` → edge_types에 따라 매핑(허용 밖이면 diagnostics)

  - `validated_by` 같은 역방향 필드는 **중복 방지 위해 생성하지 않고 조회 시 파생**


  ## 완료 기준


  - [ ] "입력필드 → edge_type" 매핑 테이블 완비

  - [ ] 샘플 5개 입력에 대한 expected nodes/edges 스냅샷 포함


  ## 참고


  - Parent Project: [[prj-1kthoh]]


  ## 짧은 회고'
notes: "# Ontology Lite v1 — Strategic Context → Graph 매핑 함수 PRD (v1.0)\n\n## 0. 요약\n\
  \nStrategic Context(JSON/옵션: 문서 body)를 입력으로 받아, Ontology Lite v1 스키마에 맞는 **nodes/edges/diagnostics**\
  \ 를 **결정론적으로** 생성한다.\\\n관계 의미는 `edge_types.yaml`에 고정되며, 본 PRD는 **입력 필드 → edge 생성\
  \ 규칙**을 표준화한다.\n\n---\n\n## 1. 배경 / 문제\n\n- Strategic Context는 구조화되어 있으나, 실행 시(LLM/agent)\
  \ 관계 의미가 흔들리면 추론 오류가 발생한다.\n\n- 특히 `validated_by` 같은 역방향 필드를 함께 생성하면 **중복/불일치**가\
  \ 누적된다.\n\n- 따라서 “**한 방향의 진실원천 필드만**”을 기준으로 **결정론적 그래프 변환**이 필요하다.\n\n---\n\n##\
  \ 2. 목표 / 비목표\n\n### 목표\n\n1. 입력(JSON/옵션: markdown body) → **nodes/edges로 결정론적 변환**\n\
  \n2. edge 생성은 `edge_types.yaml`의 from/to 제약을 항상 준수\n\n3. 허용되지 않는 관계/누락/충돌은 **diagnostics로\
  \ 기록**\n\n4. 역방향 필드(`validated_by`)는 **생성하지 않고 조회 시 파생**\n\n### 비목표\n\n- 자연어(문서\
  \ body)에서 새로운 관계를 추론해 생성 (v1에서는 금지)\n\n- edge weight 최적화/학습 기반 자동 조정\n\n- 그래프 DB\
  \ 저장/인덱싱 구현(본 PRD는 변환 규칙/인터페이스에 집중)\n\n---\n\n## 3. 사용자/시스템 시나리오\n\n- LLM Agent가\
  \ 특정 Project/Track을 seed로 받아 관련 Condition/MetaHypothesis까지 그래프 컨텍스트를 가져와 reasoning에\
  \ 사용\n\n- Dashboard/Graph 뷰가 일관된 관계(특히 validates/enables/depends_on)를 보여줌\n\n- “전략\
  \ 판단(Stop/Go)”에서 breaks/unlocks/terminates가 혼동 없이 고정된 의미로 작동\n\n---\n\n## 4. 입력\
  \ / 출력\n\n### 4.1 Input\n\n`raw_context` (필수): Strategic Context JSON 객체(예: project/track/condition/hypothesis의\
  \ raw data)\\\n`doc_body` (옵션): markdown 본문 텍스트\\\n`options` (옵션): depth/whitelist\
  \ 등 실행 옵션\n\n입력 예시(요약):\n\n- `entity_type`, `entity_id`, `entity_name`, `status`,\
  \ `parent_id`\n\n- `validates[]`\n\n- `condition_contributes[]` (to, weight, description)\n\
  \n- `outgoing_relations[]` (type, target_id, description)\n\n- (존재할 수 있음) `validated_by[]`\
  \ (v1에서는 ignore)\n\n### 4.2 Output\n\n```\n{\n  \"nodes\": [{\"id\",\"type\",\"\
  title\",\"attrs\"}],\n  \"edges\": [{\"type\",\"from_id\",\"to_id\",\"weight?\"\
  ,\"note?\",\"evidence?\",\"strength?\",\"measured_at?\"}],\n  \"diagnostics\": {\n\
  \    \"errors\": [],\n    \"warnings\": [],\n    \"info\": []\n  }\n}\n```\n\n---\n\
  \n## 5. 핵심 설계 원칙 (Deterministic Rules)\n\n1. **Canonical Edge Source**: 아래 필드만 edge\
  \ 생성 “원천”으로 인정\n\n   - `validates[]`, `condition_contributes[]`, `outgoing_relations[]`,\
  \ (추가로 허용할 경우 명시)\n\n2. **Reverse Fields Ignore**: `validated_by[]` 등 역방향은 생성 금지(중복\
  \ 방지)\n\n3. **Schema Gatekeeping**: edge 생성 전 `edge_types.yaml`의 from/to 제약 검증\n\
  \n4. **No NLP Inference v1**: 문서 body는 v1에서 관계 생성에 사용하지 않음(단, diagnostics 참고 메타로만\
  \ 가능)\n\n5. **Idempotent**: 같은 입력이면 항상 같은 nodes/edges (순서 포함, 정렬 규칙 고정)\n\n---\n\
  \n## 6. 매핑 규칙 테이블 (입력필드 → edge_type)\n\n### 6.1 `validates[]` → `validates`\n\n\
  - Source: `entity.validates: [target_id...]`\n\n- Rule:\n\n  - For each `target_id`:\n\
  \n    - Create edge `{type:\"validates\", from_id: entity_id, to_id: target_id}`\n\
  \n- Meta:\n\n  - `evidence`: 입력에 존재하면 첨부, 없으면 **warning** (edge_types에서 “required_meta\
  \ evidence”로 운영한다면 v1에서는 *옵션 A/B 중 택1*)\n\n    - 옵션 A(엄격): evidence 없으면 validates\
  \ 생성 금지 + diagnostics error\n\n    - 옵션 B(현실): validates 생성은 하되 diagnostics warning\
  \ (v1 추천)\n\n- Validation:\n\n  - from.type ∈ \\[Track, Project, Hypothesis\\]\n\
  \n  - to.type ∈ \\[Condition, MetaHypothesis\\]\n\n- Diagnostics:\n\n  - to node\
  \ 미존재 시: warning + “missing_target_node”\n\n### 6.2 `condition_contributes[]` →\
  \ `enables`\n\n- Source: `entity.condition_contributes: [{to, weight, description}]`\n\
  \n- Rule:\n\n  - For each item:\n\n    - edge `{type:\"enables\", from_id: entity_id,\
  \ to_id: item.to, weight: item.weight, note: item.description}`\n\n- Validation:\n\
  \n  - from.type ∈ \\[Track, Project\\]\n\n  - to.type ∈ \\[Condition, Track\\] (대부분\
  \ Condition)\n\n  - weight: 0\\~1 범위 아니면 warning + clamp or drop (정책 선택)\n\n- Diagnostics:\n\
  \n  - weight 누락 시: default null + warning\n\n  - description 누락 시: note null 허용\n\
  \n### 6.3 `outgoing_relations[]` → `depends_on | triggers_shutdown | ...` (허용 타입만)\n\
  \n- Source: `entity.outgoing_relations: [{type, target_id, description}]`\n\n- Rule:\n\
  \n  - relation.type이 `edge_types.yaml`에 정의된 타입이면 매핑\n\n  - v1 공식 허용 목록(권장):\n\n\
  \    - `depends_on` → 그대로 생성\n\n    - `unlocks` → 그대로 생성 (단, from이 Condition인 경우만)\n\
  \n    - `breaks` → 그대로 생성 (단, from이 Condition인 경우만)\n\n    - `terminates` → 그대로\
  \ 생성 (단, from이 Track인 경우만)\n\n  - 그 외(type 예: `triggers_shutdown`)는 **diagnostics에\
  \ 기록하고 edge 생성하지 않음** (v1)\n\n- Edge 생성:\n\n  - `{type: relation.type, from_id:\
  \ entity_id, to_id: relation.target_id, note: relation.description}`\n\n- Diagnostics:\n\
  \n  - 허용되지 않는 type: warning `\"unsupported_relation_type\"`\n\n  - edge_types 제약\
  \ 불일치: error `\"schema_violation\"`\n\n### 6.4 `validated_by[]` (역방향) → **생성 금지**\n\
  \n- Rule: ignore\n\n- Diagnostics: info `\"reverse_field_ignored\"`\n\n---\n\n##\
  \ 7. 노드 생성 규칙\n\n### 7.1 Node 최소 스펙\n\n- 입력 엔티티 자신은 항상 node로 생성\n\n- node fields:\n\
  \n  - id: `entity_id`\n\n  - type: `entity_type`\n\n  - title: `entity_name`\n\n\
  \  - attrs: status/created/updated/owner/priority_flag 등 (화이트리스트 기반)\n\n### 7.2\
  \ 참조 대상 노드(target_id)\n\n- edges가 참조하는 `to_id`가 입력에 포함되어 있지 않을 수 있음.\n\n- v1 정책(권장):\n\
  \n  - **stub node 생성 허용**\n\n    - `{id: target_id, type: \"Unknown\", title: null,\
  \ attrs:{stub:true}}`\n\n  - 단, 가능하면 caller가 multi-entity context를 넣어주도록(Track+Conditions\
  \ 같이) 설계\n\n- Diagnostics:\n\n  - stub 생성 시 info `\"stub_node_created\"`\n\n---\n\
  \n## 8. 중복/충돌 처리\n\n### 8.1 Edge dedup key\n\n- 유일키: `(type, from_id, to_id)`\n\n\
  - 동일키가 여러 번 생성되면:\n\n  - weight는 **최대값** or **마지막 wins** (정책 고정 필요)\n\n  - note는\
  \ **concat** or **last wins**\n\n- v1 추천:\n\n  - weight: max\n\n  - note: first_non_null\n\
  \n### 8.2 Conflict rules\n\n- 동일 from/to에 대해 `enables`와 `depends_on`이 동시에 생성되는 경우:\n\
  \n  - 둘 다 유지하지 않음(중복 의미 금지)\n\n  - tie-breaker:\n\n    - `depends_on` 우선(“막히면 멈춤”이\
  \ 더 강한 의미)\n\n    - enables는 drop + warning `\"edge_semantic_conflict\"`\n\n- validates와\
  \ enables 동시 생성은 허용 가능(단 의미는 다름)\n\n  - v1에서는 허용하되, validates에는 evidence 경고를 강하게\n\
  \n---\n\n## 9. 정렬/결정론(Stable Ordering)\n\n- nodes: `(type asc, id asc)`로 정렬\n\n\
  - edges: `(type asc, from_id asc, to_id asc)`로 정렬\n\n- diagnostics: 발생 순서 유지\n\n\
  ---\n\n## 10. Diagnostics 스키마\n\n### 10.1 error (변환 결과 신뢰 불가)\n\n- schema_violation\
  \ (from/to 제약 위반)\n\n- invalid_id_format (id 규칙 위반)\n\n- illegal_cycle_for_type\
  \ (cycles_allowed=false인데 cycle 감지)\n\n### 10.2 warning (변환은 하되 주의 필요)\n\n- missing_evidence_for_validates\n\
  \n- unsupported_relation_type\n\n- missing_target_node (stub 생성)\n\n- edge_semantic_conflict\n\
  \n- weight_out_of_range\n\n### 10.3 info\n\n- reverse_field_ignored\n\n- stub_node_created\n\
  \n---\n\n## 11. 인터페이스 정의 (API/함수 시그니처)\n\n### 11.1 Pure function (권장)\n\n`normalize_strategic_context(raw_context,\
  \ doc_body?, options?) -> {nodes, edges, diagnostics}`\n\noptions 예시:\n\n- `strict_validates_evidence:\
  \ boolean` (default false)\n\n- `create_stub_nodes: boolean` (default true)\n\n\
  - `allowed_outgoing_types: string[]` (default \\[\"depends_on\",\"unlocks\",\"breaks\"\
  ,\"terminates\"\\])\n\n- `dedup_policy: {weight:\"max\", note:\"first_non_null\"\
  }`\n\n---\n\n## 12. 샘플 5개 입력 → expected snapshot\n\n### Sample 1: Project(validates\
  \ + condition_contributes)\n\nInput(요약):\n\n- entity: Project prj-002\n\n- validates:\
  \ \\[hyp-6-09, hyp-6-10\\]\n\n- condition_contributes: \\[{to:\"cond-d\", weight:0.6,\
  \ description:\"펀딩 성공 시 런웨이\"}\\]\n\nExpected:\n\n- nodes: prj-002(Project), hyp-6-09(Unknown\
  \ stub or Hypothesis if present), hyp-6-10(...), cond-d(...)\n\n- edges:\n\n  -\
  \ validates prj-002 -&gt; hyp-6-09\n\n  - validates prj-002 -&gt; hyp-6-10\n\n \
  \ - enables prj-002 -&gt; cond-d (weight 0.6)\n\n### Sample 2: Track(outgoing_relations\
  \ depends_on)\n\nInput:\n\n- entity: Track trk-6\n\n- outgoing_relations: \\[{type:\"\
  depends_on\", target_id:\"trk-1\", description:\"제품이 유료화 기반\"}\\]\n\nExpected:\n\
  \n- edge depends_on trk-6 -&gt; trk-1\n\n### Sample 3: Condition(outgoing_relations\
  \ triggers_shutdown)\n\nInput:\n\n- entity: Condition cond-b\n\n- outgoing_relations:\
  \ \\[{type:\"triggers_shutdown\", target_id:\"action:data_strategy_shutdown\"}\\\
  ]\n\nExpected:\n\n- edges: (생성 없음)\n\n- warning: unsupported_relation_type\n\n###\
  \ Sample 4: Condition(unlocks/breaks)\n\nInput:\n\n- entity: Condition cond-b\n\n\
  - outgoing_relations: \\[{type:\"unlocks\", target_id:\"phase-01\"} , {type:\"breaks\"\
  , target_id:\"str-01\"}\\]\n\nExpected:\n\n- unlocks cond-b -&gt; phase-01\n\n-\
  \ breaks cond-b -&gt; str-01 (+ break_trigger 없으면 warning 또는 error: 정책 필요)\n\n###\
  \ Sample 5: validated_by 포함\n\nInput:\n\n- entity: Condition cond-b\n\n- validated_by:\
  \ \\[\"trk-2\",\"mh-3\"\\]\n\nExpected:\n\n- info: reverse_field_ignored\n\n- (edges\
  \ 생성 없음)\n\n---\n\n## 13. 완료 기준(수용 테스트)\n\n- 입력필드→edge_type 매핑 테이블이 본 PRD와 일치\n\n\
  - 5개 샘플의 expected snapshot이 구현 결과와 동일\n\n- 동일 입력 10회 실행해도 nodes/edges 순서 포함 동일\n\
  \n- unsupported/violation은 diagnostics에 반드시 남는다\n\n---\n\n## 14. 오픈 이슈(결정 필요, v1에서의\
  \ 기본값 제안)\n\n1. validates에 evidence 없을 때:\n\n   - **v1 제안:** edge 생성 + warning (현실적)\n\
  \n2. breaks의 break_trigger 필수 강제:\n\n   - **v1 제안:** 없으면 warning (추후 v1.1에서 error로\
  \ 강화)\n\n3. stub node 생성 여부:\n\n   - **v1 제안:** true (agent가 그래프를 끊기지 않게)\n\n---"
---
# Ontology Lite v1 - Strategic Context 매핑 함수 PRD 작성

## 문제

Strategic Context는 일부 구조화되어 있어도, 관계 의미가 런타임에서 흔들릴 수 있다. 매핑 함수를 통해 결정론적 그래프 변환이 필요하다.

## 목표

Strategic Context 입력(JSON/필드/문서)을 받아 **Ontology Lite v1 nodes/edges로 결정론적으로 변환**하는 규칙/테이블/인터페이스를 PRD로 확정한다.

## 입력/출력

### Input

- project/track/condition/hypothesis raw context(JSON)
- (옵션) 문서 body(마크다운)

### Output

- nodes: `[{id, type, name, attrs...}]`
- edges: `[{type, from, to, weight?, description?, evidence?}]`
- diagnostics: 누락/충돌/불확실성 로그

## 매핑 규칙(초안)

- `validates[]` → validates edge 생성
- `condition_contributes[]` → enables edge(+weight)
- `outgoing_relations[]` → edge_types에 따라 매핑(허용 밖이면 diagnostics)
- `validated_by` 같은 역방향 필드는 **중복 방지 위해 생성하지 않고 조회 시 파생**

## 완료 기준

- [ ] "입력필드 → edge_type" 매핑 테이블 완비
- [ ] 샘플 5개 입력에 대한 expected nodes/edges 스냅샷 포함

## 참고

- Parent Project: [[prj-1kthoh]]

## 짧은 회고
