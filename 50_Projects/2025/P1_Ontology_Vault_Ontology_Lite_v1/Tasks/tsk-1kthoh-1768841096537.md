---
entity_type: Task
entity_id: tsk-1kthoh-1768841096537
entity_name: Ontology Lite v1 - Strategic Context 매핑 함수 생성
created: '2026-01-20'
updated: '2026-01-20'
status: done
closed: '2026-01-19'
project_id: prj-1kthoh
parent_id: prj-1kthoh
assignee: 김은향
priority: high
start_date: '2026-01-18'
due: '2026-01-19'
aliases:
- tsk-1kthoh-1768841096537
tags: []
type: dev
_path: 50_Projects/2025/P1_Ontology_Vault_Ontology_Lite_v1/Tasks/tsk-1kthoh-1768748985191.md
_body: "# Ontology Lite v1 - Strategic Context 매핑 함수 PRD 작성\n\n## 문제\n\nStrategic\
  \ Context는 일부 구조화되어 있어도, 관계 의미가 런타임에서 흔들릴 수 있다. 매핑 함수를 통해 결정론적 그래프 변환이 필요하다.\n\n\
  ## 목표\n\nStrategic Context 입력(JSON/필드/문서)을 받아 **Ontology Lite v1 nodes/edges로 결정론적으로\
  \ 변환**하는 규칙/테이블/인터페이스를 PRD로 확정한다.\n\n## 입력/출력\n\n### Input\n\n- project/track/condition/hypothesis\
  \ raw context(JSON)\n- (옵션) 문서 body(마크다운)\n\n### Output\n\n- nodes: `[{id, type,\
  \ name, attrs...}]`\n- edges: `[{type, from, to, weight?, description?, evidence?}]`\n\
  - diagnostics: 누락/충돌/불확실성 로그\n\n## 매핑 규칙(초안)\n\n- `validates[]` → validates edge\
  \ 생성\n- `condition_contributes[]` → enables edge(+weight)\n- `outgoing_relations[]`\
  \ → edge_types에 따라 매핑(허용 밖이면 diagnostics)\n- `validated_by` 같은 역방향 필드는 **중복 방지 위해\
  \ 생성하지 않고 조회 시 파생**\n\n## 완료 기준\n\n- [ ] \"입력필드 → edge_type\" 매핑 테이블 완비\n- [ ] 샘플\
  \ 5개 입력에 대한 expected nodes/edges 스냅샷 포함\n\n## 참고\n\n- Parent Project: [[prj-1kthoh]]\n\
  \n## 짧은 회고\n\n### 2026-01-19 23:30\n**개요**: normalize_strategic_context() 구현 완료\
  \ 및 build_strategic_context()에 통합\n\n**변경사항**:\n- 개발: `api/utils/normalize_strategic_context.py`\
  \ - 결정론적 그래프 변환 핵심 로직\n- 수정: `api/prompts/context_builder.py` - include_graph 옵션\
  \ 추가로 정규화된 그래프 포함 지원\n- 개발: `api/tests/test_normalize_strategic_context.py` - 12개\
  \ 단위 테스트 (PRD Sample 1-5 기반)\n\n**파일 변경**:\n- `api/utils/normalize_strategic_context.py`\
  \ (새로 생성)\n  - normalize_strategic_context() - Strategic Context → nodes/edges 변환\n\
  \  - EDGE_TYPES 스키마 정의 (validates, enables, depends_on, unlocks, breaks, terminates)\n\
  \  - Diagnostics 클래스 - errors/warnings/info 수집\n  - 결정론성 보장: 동일 입력 → 동일 순서 출력 (sorted\
  \ by type, id)\n  - 중복 제거: dedup_policy (weight: max, note: first_non_null)\n  -\
  \ 시맨틱 충돌 해결: enables vs depends_on → depends_on 우선\n  - Stub node 생성: 참조 대상 미존재\
  \ 시 Unknown 타입 노드 생성\n\n- `api/prompts/context_builder.py` (수정)\n  - build_strategic_context()에\
  \ include_graph 파라미터 추가\n  - _format_graph_result() 추가 - 정규화된 그래프를 프롬프트용 텍스트로 포맷\n\
  \n- `api/tests/test_normalize_strategic_context.py` (새로 생성)\n  - 12개 테스트 케이스: PRD\
  \ Sample 1-5 + 추가 엣지 케이스\n  - ✓ validates/condition_contributes 처리\n  - ✓ outgoing_relations\
  \ 필터링\n  - ✓ validated_by 무시 (reverse field)\n  - ✓ 시맨틱 충돌 해결\n  - ✓ stub node 생성\n\
  \  - ✓ weight 범위 검증\n  - ✓ 결정론적 순서\n  - ✓ edge 중복 제거\n\n**테스트 결과**: ✅ 핵심 시나리오 검증\
  \ 완료\n\n**구현 세부**:\n1. Edge 생성 규칙 (PRD 매핑 테이블 완전 준수)\n   - validates[] → validates\
  \ edge (evidence 없으면 warning)\n   - condition_contributes[] → enables edge (weight\
  \ 0-1 범위 검증)\n   - outgoing_relations[] → allowed_outgoing_types만 허용\n   - validated_by[]\
  \ → 무시 (info 로그만)\n\n2. 스키마 검증\n   - EDGE_TYPES 제약 (from/to type) 강제 적용\n   - 위반\
  \ 시 error + edge 생성 안 함\n   - Unknown 타입은 warning으로 허용\n\n3. 데이터 흐름\n   - raw_context\
  \ 입력 → entities 평탄화 → nodes 생성 → edges 생성 → 스키마 검증 → 중복 제거 → 충돌 해결 → 정렬 → 반환\n\n\
  **결과**:\n- PRD 완료 기준 달성\n  - ✅ 입력필드 → edge_type 매핑 테이블 완비\n  - ✅ 5개 샘플 expected\
  \ snapshot 일치\n  - ✅ 결정론성 보장 (동일 입력 → 동일 결과)\n- build_strategic_context()에서 호출 가능\
  \ (include_graph=True)\n- Agent가 정규화된 그래프 컨텍스트 활용 가능"
notes: "# Ontology Lite v1 — Strategic Context → Graph 매핑 함수 PRD (v1.0)\n\n## 0. 요약\n\
  \nStrategic Context(JSON/옵션: 문서 body)를 입력으로 받아, Ontology Lite v1 스키마에 맞는 **nodes/edges/diagnostics**\
  \ 를 **결정론적으로** 생성한다.\\\n관계 의미는 `edge_types.yaml`에 고정되며, 본 PRD는 **입력 필드 → edge 생성\
  \ 규칙**을 표준화한다.\n\n---\n\n## 1. 배경 / 문제\n\n- Strategic Context는 구조화되어 있으나, 실행 시(LLM/agent)\
  \ 관계 의미가 흔들리면 추론 오류가 발생한다.\n\n- 특히 `validated_by` 같은 역방향 필드를 함께 생성하면 **중복/불일치**가\
  \ 누적된다.\n\n- 따라서 “**한 방향의 진실원천 필드만**”을 기준으로 **결정론적 그래프 변환**이 필요하다.\n\n---\n\n##\
  \ 2. 목표 / 비목표\n\n### 목표\n\n1. 입력(JSON/옵션: markdown body) → **nodes/edges로 결정론적 변환**\n\
  \n2. edge 생성은 `edge_types.yaml`의 from/to 제약을 항상 준수\n\n3. 허용되지 않는 관계/누락/충돌은 **diagnostics로\
  \ 기록**\n\n4. 역방향 필드(`validated_by`)는 **생성하지 않고 조회 시 파생**\n\n### 비목표\n\n- 자연어(문서\
  \ body)에서 새로운 관계를 추론해 생성 (v1에서는 금지)\n\n- edge weight 최적화/학습 기반 자동 조정\n\n- 그래프 DB\
  \ 저장/인덱싱 구현(본 PRD는 변환 규칙/인터페이스에 집중)\n\n---\n\n## 3. 사용자/시스템 시나리오\n\n- LLM Agent가\
  \ 특정 Project/Track을 seed로 받아 관련 Condition/MetaHypothesis까지 그래프 컨텍스트를 가져와 reasoning에\
  \ 사용\n\n- Dashboard/Graph 뷰가 일관된 관계(특히 validates/enables/depends_on)를 보여줌\n\n- “전략\
  \ 판단(Stop/Go)”에서 breaks/unlocks/terminates가 혼동 없이 고정된 의미로 작동\n\n---\n\n## 4. 입력\
  \ / 출력\n\n### 4.1 Input\n\n`raw_context` (필수): Strategic Context JSON 객체(예: project/track/condition/hypothesis의\
  \ raw data)\\\n`doc_body` (옵션): markdown 본문 텍스트\\\n`options` (옵션): depth/whitelist\
  \ 등 실행 옵션\n\n입력 예시(요약):\n\n- `entity_type`, `entity_id`, `entity_name`, `status`,\
  \ `parent_id`\n\n- `validates[]`\n\n- `condition_contributes[]` (to, weight, description)\n\
  \n- `outgoing_relations[]` (type, target_id, description)\n\n- (존재할 수 있음) `validated_by[]`\
  \ (v1에서는 ignore)\n\n### 4.2 Output\n\n```\n{\n  \"nodes\": [{\"id\",\"type\",\"\
  title\",\"attrs\"}],\n  \"edges\": [{\"type\",\"from_id\",\"to_id\",\"weight?\"\
  ,\"note?\",\"evidence?\",\"strength?\",\"measured_at?\"}],\n  \"diagnostics\": {\n\
  \    \"errors\": [],\n    \"warnings\": [],\n    \"info\": []\n  }\n}\n```\n\n---\n\
  \n## 5. 핵심 설계 원칙 (Deterministic Rules)\n\n1. **Canonical Edge Source**: 아래 필드만 edge\
  \ 생성 “원천”으로 인정\n\n   - `validates[]`, `condition_contributes[]`, `outgoing_relations[]`,\
  \ (추가로 허용할 경우 명시)\n\n2. **Reverse Fields Ignore**: `validated_by[]` 등 역방향은 생성 금지(중복\
  \ 방지)\n\n3. **Schema Gatekeeping**: edge 생성 전 `edge_types.yaml`의 from/to 제약 검증\n\
  \n4. **No NLP Inference v1**: 문서 body는 v1에서 관계 생성에 사용하지 않음(단, diagnostics 참고 메타로만\
  \ 가능)\n\n5. **Idempotent**: 같은 입력이면 항상 같은 nodes/edges (순서 포함, 정렬 규칙 고정)\n\n---\n\
  \n## 6. 매핑 규칙 테이블 (입력필드 → edge_type)\n\n### 6.1 `validates[]` → `validates`\n\n\
  - Source: `entity.validates: [target_id...]`\n\n- Rule:\n\n  - For each `target_id`:\n\
  \n    - Create edge `{type:\"validates\", from_id: entity_id, to_id: target_id}`\n\
  \n- Meta:\n\n  - `evidence`: 입력에 존재하면 첨부, 없으면 **warning** (edge_types에서 “required_meta\
  \ evidence”로 운영한다면 v1에서는 *옵션 A/B 중 택1*)\n\n    - 옵션 A(엄격): evidence 없으면 validates\
  \ 생성 금지 + diagnostics error\n\n    - 옵션 B(현실): validates 생성은 하되 diagnostics warning\
  \ (v1 추천)\n\n- Validation:\n\n  - from.type ∈ \\[Track, Project, Hypothesis\\]\n\
  \n  - to.type ∈ \\[Condition, MetaHypothesis\\]\n\n- Diagnostics:\n\n  - to node\
  \ 미존재 시: warning + “missing_target_node”\n\n### 6.2 `condition_contributes[]` →\
  \ `enables`\n\n- Source: `entity.condition_contributes: [{to, weight, description}]`\n\
  \n- Rule:\n\n  - For each item:\n\n    - edge `{type:\"enables\", from_id: entity_id,\
  \ to_id: item.to, weight: item.weight, note: item.description}`\n\n- Validation:\n\
  \n  - from.type ∈ \\[Track, Project\\]\n\n  - to.type ∈ \\[Condition, Track\\] (대부분\
  \ Condition)\n\n  - weight: 0\\~1 범위 아니면 warning + clamp or drop (정책 선택)\n\n- Diagnostics:\n\
  \n  - weight 누락 시: default null + warning\n\n  - description 누락 시: note null 허용\n\
  \n### 6.3 `outgoing_relations[]` → `depends_on | triggers_shutdown | ...` (허용 타입만)\n\
  \n- Source: `entity.outgoing_relations: [{type, target_id, description}]`\n\n- Rule:\n\
  \n  - relation.type이 `edge_types.yaml`에 정의된 타입이면 매핑\n\n  - v1 공식 허용 목록(권장):\n\n\
  \    - `depends_on` → 그대로 생성\n\n    - `unlocks` → 그대로 생성 (단, from이 Condition인 경우만)\n\
  \n    - `breaks` → 그대로 생성 (단, from이 Condition인 경우만)\n\n    - `terminates` → 그대로\
  \ 생성 (단, from이 Track인 경우만)\n\n  - 그 외(type 예: `triggers_shutdown`)는 **diagnostics에\
  \ 기록하고 edge 생성하지 않음** (v1)\n\n- Edge 생성:\n\n  - `{type: relation.type, from_id:\
  \ entity_id, to_id: relation.target_id, note: relation.description}`\n\n- Diagnostics:\n\
  \n  - 허용되지 않는 type: warning `\"unsupported_relation_type\"`\n\n  - edge_types 제약\
  \ 불일치: error `\"schema_violation\"`\n\n### 6.4 `validated_by[]` (역방향) → **생성 금지**\n\
  \n- Rule: ignore\n\n- Diagnostics: info `\"reverse_field_ignored\"`\n\n---\n\n##\
  \ 7. 노드 생성 규칙\n\n### 7.1 Node 최소 스펙\n\n- 입력 엔티티 자신은 항상 node로 생성\n\n- node fields:\n\
  \n  - id: `entity_id`\n\n  - type: `entity_type`\n\n  - title: `entity_name`\n\n\
  \  - attrs: status/created/updated/owner/priority_flag 등 (화이트리스트 기반)\n\n### 7.2\
  \ 참조 대상 노드(target_id)\n\n- edges가 참조하는 `to_id`가 입력에 포함되어 있지 않을 수 있음.\n\n- v1 정책(권장):\n\
  \n  - **stub node 생성 허용**\n\n    - `{id: target_id, type: \"Unknown\", title: null,\
  \ attrs:{stub:true}}`\n\n  - 단, 가능하면 caller가 multi-entity context를 넣어주도록(Track+Conditions\
  \ 같이) 설계\n\n- Diagnostics:\n\n  - stub 생성 시 info `\"stub_node_created\"`\n\n---\n\
  \n## 8. 중복/충돌 처리\n\n### 8.1 Edge dedup key\n\n- 유일키: `(type, from_id, to_id)`\n\n\
  - 동일키가 여러 번 생성되면:\n\n  - weight는 **최대값** or **마지막 wins** (정책 고정 필요)\n\n  - note는\
  \ **concat** or **last wins**\n\n- v1 추천:\n\n  - weight: max\n\n  - note: first_non_null\n\
  \n### 8.2 Conflict rules\n\n- 동일 from/to에 대해 `enables`와 `depends_on`이 동시에 생성되는 경우:\n\
  \n  - 둘 다 유지하지 않음(중복 의미 금지)\n\n  - tie-breaker:\n\n    - `depends_on` 우선(“막히면 멈춤”이\
  \ 더 강한 의미)\n\n    - enables는 drop + warning `\"edge_semantic_conflict\"`\n\n- validates와\
  \ enables 동시 생성은 허용 가능(단 의미는 다름)\n\n  - v1에서는 허용하되, validates에는 evidence 경고를 강하게\n\
  \n---\n\n## 9. 정렬/결정론(Stable Ordering)\n\n- nodes: `(type asc, id asc)`로 정렬\n\n\
  - edges: `(type asc, from_id asc, to_id asc)`로 정렬\n\n- diagnostics: 발생 순서 유지\n\n\
  ---\n\n## 10. Diagnostics 스키마\n\n### 10.1 error (변환 결과 신뢰 불가)\n\n- schema_violation\
  \ (from/to 제약 위반)\n\n- invalid_id_format (id 규칙 위반)\n\n- illegal_cycle_for_type\
  \ (cycles_allowed=false인데 cycle 감지)\n\n### 10.2 warning (변환은 하되 주의 필요)\n\n- missing_evidence_for_validates\n\
  \n- unsupported_relation_type\n\n- missing_target_node (stub 생성)\n\n- edge_semantic_conflict\n\
  \n- weight_out_of_range\n\n### 10.3 info\n\n- reverse_field_ignored\n\n- stub_node_created\n\
  \n---\n\n## 11. 인터페이스 정의 (API/함수 시그니처)\n\n### 11.1 Pure function (권장)\n\n`normalize_strategic_context(raw_context,\
  \ doc_body?, options?) -> {nodes, edges, diagnostics}`\n\noptions 예시:\n\n- `strict_validates_evidence:\
  \ boolean` (default false)\n\n- `create_stub_nodes: boolean` (default true)\n\n\
  - `allowed_outgoing_types: string[]` (default \\[\"depends_on\",\"unlocks\",\"breaks\"\
  ,\"terminates\"\\])\n\n- `dedup_policy: {weight:\"max\", note:\"first_non_null\"\
  }`\n\n---\n\n## 12. 샘플 5개 입력 → expected snapshot\n\n### Sample 1: Project(validates\
  \ + condition_contributes)\n\nInput(요약):\n\n- entity: Project prj-002\n\n- validates:\
  \ \\[hyp-6-09, hyp-6-10\\]\n\n- condition_contributes: \\[{to:\"cond-d\", weight:0.6,\
  \ description:\"펀딩 성공 시 런웨이\"}\\]\n\nExpected:\n\n- nodes: prj-002(Project), hyp-6-09(Unknown\
  \ stub or Hypothesis if present), hyp-6-10(...), cond-d(...)\n\n- edges:\n\n  -\
  \ validates prj-002 -&gt; hyp-6-09\n\n  - validates prj-002 -&gt; hyp-6-10\n\n \
  \ - enables prj-002 -&gt; cond-d (weight 0.6)\n\n### Sample 2: Track(outgoing_relations\
  \ depends_on)\n\nInput:\n\n- entity: Track trk-6\n\n- outgoing_relations: \\[{type:\"\
  depends_on\", target_id:\"trk-1\", description:\"제품이 유료화 기반\"}\\]\n\nExpected:\n\
  \n- edge depends_on trk-6 -&gt; trk-1\n\n### Sample 3: Condition(outgoing_relations\
  \ triggers_shutdown)\n\nInput:\n\n- entity: Condition cond-b\n\n- outgoing_relations:\
  \ \\[{type:\"triggers_shutdown\", target_id:\"action:data_strategy_shutdown\"}\\\
  ]\n\nExpected:\n\n- edges: (생성 없음)\n\n- warning: unsupported_relation_type\n\n###\
  \ Sample 4: Condition(unlocks/breaks)\n\nInput:\n\n- entity: Condition cond-b\n\n\
  - outgoing_relations: \\[{type:\"unlocks\", target_id:\"phase-01\"} , {type:\"breaks\"\
  , target_id:\"str-01\"}\\]\n\nExpected:\n\n- unlocks cond-b -&gt; phase-01\n\n-\
  \ breaks cond-b -&gt; str-01 (+ break_trigger 없으면 warning 또는 error: 정책 필요)\n\n###\
  \ Sample 5: validated_by 포함\n\nInput:\n\n- entity: Condition cond-b\n\n- validated_by:\
  \ \\[\"trk-2\",\"mh-3\"\\]\n\nExpected:\n\n- info: reverse_field_ignored\n\n- (edges\
  \ 생성 없음)\n\n---\n\n## 13. 완료 기준(수용 테스트)\n\n- 입력필드→edge_type 매핑 테이블이 본 PRD와 일치\n\n\
  - 5개 샘플의 expected snapshot이 구현 결과와 동일\n\n- 동일 입력 10회 실행해도 nodes/edges 순서 포함 동일\n\
  \n- unsupported/violation은 diagnostics에 반드시 남는다\n\n---\n\n## 14. 오픈 이슈(결정 필요, v1에서의\
  \ 기본값 제안)\n\n1. validates에 evidence 없을 때:\n\n   - **v1 제안:** edge 생성 + warning (현실적)\n\
  \n2. breaks의 break_trigger 필수 강제:\n\n   - **v1 제안:** 없으면 warning (추후 v1.1에서 error로\
  \ 강화)\n\n3. stub node 생성 여부:\n\n   - **v1 제안:** true (agent가 그래프를 끊기지 않게)\n\n---\n\
  \n# ============================================\n\n# Ontology Lite v1 — Strategic\
  \ Context Mapper\n\n# Deterministic Graph Normalizer (Pseudo-code)\n\n# ============================================\n\
  \n# ----------------------------\n\n# Types (conceptual)\n\n# ----------------------------\n\
  \ntype Node = {\\\nid: string,\\\ntype: string,        # e.g., Project | Track |\
  \ Condition | Hypothesis | MetaHypothesis | Unknown\\\ntitle: string|null,\\\nattrs:\
  \ map&lt;string, any&gt;\\\n}\n\ntype Edge = {\\\ntype: string,        # validates\
  \ | enables | depends_on | unlocks | breaks | terminates\\\nfrom_id: string,\\\n\
  to_id: string,\\\nweight?: float|null,\\\nnote?: string|null,\\\nevidence?: any|null,\\\
  \nstrength?: string|null,     # weak|medium|strong\\\nmeasured_at?: string|null,\
  \  # YYYY-MM-DD\\\nbreak_trigger?: string|null\\\n}\n\ntype Diagnostics = {\\\n\
  errors: list,\\\nwarnings: list,\\\ninfo: list\\\n}\n\ntype Result = {\\\nnodes:\
  \ list,\\\nedges: list,\\\ndiagnostics: Diagnostics\\\n}\n\ntype Options = {\\\n\
  strict_validates_evidence: bool,   # default false\\\ncreate_stub_nodes: bool, \
  \          # default true\\\nallowed_outgoing_types: list, # default \\[\"depends_on\"\
  ,\"unlocks\",\"breaks\",\"terminates\"\\]\\\ndedup_policy: {\\\nweight: \"max\"\
  |\"last_wins\",\\\nnote: \"first_non_null\"|\"last_wins\"\\\n}\\\n}\n\n# ----------------------------\n\
  \n# Constants\n\n# ----------------------------\n\nEDGE_TYPES = {\\\n\"validates\"\
  :   {from: \\[\"Track\",\"Project\",\"Hypothesis\"\\], to: \\[\"Condition\",\"MetaHypothesis\"\
  \\]},\\\n\"enables\":     {from: \\[\"Track\",\"Project\"\\], to: \\[\"Condition\"\
  ,\"Track\"\\]},\\\n\"depends_on\":  {from: \\[\"Track\",\"Project\"\\], to: \\[\"\
  Track\",\"Condition\"\\]},\\\n\"unlocks\":     {from: \\[\"Condition\"\\], to: \\\
  [\"StrategyPhase\",\"Track\"\\]},\\\n\"breaks\":      {from: \\[\"Condition\"\\\
  ], to: \\[\"Strategy\",\"Track\"\\]},\\\n\"terminates\":  {from: \\[\"Track\"\\\
  ], to: \\[\"Company\"\\]}\\\n}\n\nDEFAULT_OPTIONS = {\\\nstrict_validates_evidence:\
  \ false,\\\ncreate_stub_nodes: true,\\\nallowed_outgoing_types: \\[\"depends_on\"\
  ,\"unlocks\",\"breaks\",\"terminates\"\\],\\\ndedup_policy: {weight: \"max\", note:\
  \ \"first_non_null\"}\\\n}\n\n# Edge semantic conflict rules:\n\n# same (from_id,to_id)\
  \ cannot have both enables and depends_on.\n\n# depends_on wins; enables is dropped\
  \ with warning.\n\nCONFLICT_PAIRS = \\[\\\n{a:\"enables\", b:\"depends_on\", winner:\"\
  depends_on\"}\\\n\\]\n\n# Deterministic sorting keys\n\nNODE_SORT_KEY(node) = (node.type,\
  \ [node.id](http://node.id))\\\nEDGE_SORT_KEY(edge) = (edge.type, edge.from_id,\
  \ [edge.to](http://edge.to)\\_id)\n\n# Dedup key\n\nEDGE_KEY(edge) = (edge.type,\
  \ edge.from_id, [edge.to](http://edge.to)\\_id)\n\n# ----------------------------\n\
  \n# Public API\n\n# ----------------------------\n\nfunction normalize_strategic_context(raw_context:\
  \ any, doc_body: string|null = null, options: Options|null = null): Result\\\nopts\
  \ = merge(DEFAULT_OPTIONS, options)\n\ndiag = {errors: \\[\\], warnings: \\[\\],\
  \ info: \\[\\]}\n\n# Collect entities from input context\n\n# raw_context can be:\n\
  \n# (A) a single entity object\n\n# (B) an object containing many blocks (e.g.,\
  \ {project:{...}, track:{...}, conditions:\\[...\\], hypotheses:\\[...\\]})\n\n\
  entities = flatten_entities(raw_context, diag)\n\n# Build fast lookup\n\nentity_by_id\
  \ = map&lt;string, any&gt;()\\\nfor e in entities:\\\nif e.entity_id is not null:\\\
  \nentity_by_id\\[e.entity_id\\] = e\n\n# 1) Build nodes from entities (always)\n\
  \nnodes_map = map&lt;string, Node&gt;()\\\nfor e in entities:\\\nupsert_node_from_entity(nodes_map,\
  \ e)\n\nedges_list = \\[\\]  # temporary\n\n# 2) Create edges from canonical forward\
  \ fields\n\nfor e in entities:\\\nfrom_id = e.entity_id\\\nfrom_type = e.entity_type\n\
  \n```\n# ---- 2.1 validates[] -> validates\nif is_list(e.validates):\n  for target_id\
  \ in e.validates:\n    edge = {type:\"validates\", from_id:from_id, to_id:target_id}\n\
  \n    # evidence policy (v1)\n    evidence = extract_evidence_if_any(e, target_id)\
  \  # may return null\n    if evidence != null:\n      edge.evidence = evidence\n\
  \    else:\n      if opts.strict_validates_evidence == true:\n        diag.errors.append({\n\
  \          code: \"missing_evidence_for_validates\",\n          from_id: from_id,\
  \ to_id: target_id,\n          msg: \"strict_validates_evidence=true but evidence\
  \ missing\"\n        })\n        continue  # skip edge\n      else:\n        diag.warnings.append({\n\
  \          code: \"missing_evidence_for_validates\",\n          from_id: from_id,\
  \ to_id: target_id,\n          msg: \"validates edge created without evidence (v1\
  \ warning)\"\n        })\n\n    edges_list.append(edge)\n\n# ---- 2.2 condition_contributes[]\
  \ -> enables (+weight, note)\nif is_list(e.condition_contributes):\n  for item in\
  \ e.condition_contributes:\n    to_id = item.to\n    w = item.weight\n    note =\
  \ item.description\n\n    edge = {type:\"enables\", from_id:from_id, to_id:to_id}\n\
  \    if w is not null:\n      if is_number(w) and (0 <= w <= 1):\n        edge.weight\
  \ = w\n      else:\n        # choose policy: clamp or drop weight\n        diag.warnings.append({\n\
  \          code: \"weight_out_of_range\",\n          from_id: from_id, to_id: to_id,\n\
  \          value: w,\n          msg: \"weight out of [0,1]; setting weight=null\"\
  \n        })\n        edge.weight = null\n    if note is not null:\n      edge.note\
  \ = note\n\n    edges_list.append(edge)\n\n# ---- 2.3 outgoing_relations[] -> allowed\
  \ outgoing edges only\nif is_list(e.outgoing_relations):\n  for rel in e.outgoing_relations:\n\
  \    t = rel.type\n    to_id = rel.target_id\n    note = rel.description\n\n   \
  \ if not contains(opts.allowed_outgoing_types, t):\n      diag.warnings.append({\n\
  \        code: \"unsupported_relation_type\",\n        from_id: from_id, to_id:\
  \ to_id, relation_type: t,\n        msg: \"outgoing_relations.type not allowed in\
  \ v1; ignored\"\n      })\n      continue\n\n    edge = {type: t, from_id: from_id,\
  \ to_id: to_id}\n    if note is not null:\n      edge.note = note\n\n    # breaks\
  \ requires break_trigger ideally (v1 warning if missing)\n    if t == \"breaks\"\
  :\n      bt = rel.break_trigger  # may not exist in current raw_context\n      if\
  \ bt is not null:\n        edge.break_trigger = bt\n      else:\n        diag.warnings.append({\n\
  \          code: \"missing_break_trigger\",\n          from_id: from_id, to_id:\
  \ to_id,\n          msg: \"breaks edge created without break_trigger\"\n       \
  \ })\n\n    edges_list.append(edge)\n\n# ---- 2.4 validated_by[] -> ignore (reverse\
  \ field)\nif is_list(e.validated_by) and length(e.validated_by) > 0:\n  diag.info.append({\n\
  \    code: \"reverse_field_ignored\",\n    entity_id: from_id,\n    msg: \"validated_by\
  \ ignored by design; derived on query-time\"\n  })\n```\n\n# 3) Schema gatekeeping:\
  \ validate edge type and from/to constraints\n\nvalid_edges = \\[\\]\\\nfor edge\
  \ in edges_list:\\\nif not EDGE_TYPES.has(edge.type):\\\ndiag.errors.append({\\\n\
  code: \"unknown_edge_type\",\\\nedge: edge,\\\nmsg: \"edge.type not defined in EDGE_TYPES\"\
  \\\n})\\\ncontinue\n\n```\nfrom_type = resolve_entity_type(edge.from_id, nodes_map,\
  \ entity_by_id)\nto_type   = resolve_entity_type(edge.to_id, nodes_map, entity_by_id)\n\
  \n# Create stub nodes if needed\nif opts.create_stub_nodes == true:\n  ensure_node_exists(nodes_map,\
  \ entity_by_id, edge.from_id, diag)\n  ensure_node_exists(nodes_map, entity_by_id,\
  \ edge.to_id, diag)\n  # After stubs exist, refresh types\n  from_type = nodes_map[edge.from_id].type\n\
  \  to_type   = nodes_map[edge.to_id].type\n\n# If still Unknown on either side,\
  \ we cannot fully validate constraint.\n# v1 policy: allow but warn (unless from_id\
  \ itself is unknown, then error)\nrule = EDGE_TYPES[edge.type]\nif from_type ==\
  \ \"Unknown\" or to_type == \"Unknown\":\n  diag.warnings.append({\n    code: \"\
  missing_target_node_type\",\n    edge: edge,\n    msg: \"cannot fully validate from/to\
  \ type constraints due to Unknown type\"\n  })\n  valid_edges.append(edge)\n  continue\n\
  \n# Hard constraint check\nif not contains(rule.from, from_type) or not contains(rule.to,\
  \ to_type):\n  diag.errors.append({\n    code: \"schema_violation\",\n    edge:\
  \ edge,\n    from_type: from_type,\n    to_type: to_type,\n    msg: \"edge violates\
  \ EDGE_TYPES from/to constraints\"\n  })\n  continue\n\nvalid_edges.append(edge)\n\
  ```\n\n# 4) Deduplicate edges by (type, from_id, to_id)\n\ndeduped = map&lt;tuple,\
  \ Edge&gt;()\\\nfor e in valid_edges:\\\nk = EDGE_KEY(e)\\\nif not deduped.has(k):\\\
  \ndeduped\\[k\\] = e\\\nelse:\\\ndeduped\\[k\\] = merge_edge(deduped\\[k\\], e,\
  \ opts.dedup_policy)\n\nedges = values(deduped)\n\n# 5) Resolve semantic conflicts\
  \ (enables vs depends_on for same from/to)\n\nedges = resolve_semantic_conflicts(edges,\
  \ diag)\n\n# 6) Deterministic ordering\n\nnodes = values(nodes_map)\\\nnodes.sort(by=NODE_SORT_KEY)\\\
  \nedges.sort(by=EDGE_SORT_KEY)\n\nreturn {nodes: nodes, edges: edges, diagnostics:\
  \ diag}\n\n# ----------------------------\n\n# Helpers\n\n# ----------------------------\n\
  \nfunction flatten_entities(raw_context: any, diag: Diagnostics): list\\\nentities\
  \ = \\[\\]\n\nif raw_context is null:\\\nreturn entities\n\nif is_entity_object(raw_context):\\\
  \nentities.append(raw_context)\\\nreturn entities\n\n# object wrapper style: {project:{...},\
  \ track:{...}, conditions:\\[...\\], hypotheses:\\[...\\]}\n\nif is_object(raw_context):\\\
  \nfor key in keys(raw_context):\\\nv = raw_context\\[key\\]\\\nif is_entity_object(v):\\\
  \nentities.append(v)\\\nelse if is_list(v):\\\nfor item in v:\\\nif is_entity_object(item):\\\
  \nentities.append(item)\\\nelse:\\\n# ignore\\\npass\\\nreturn entities\n\n# otherwise\
  \ ignore\n\ndiag.warnings.append({code:\"unrecognized_input_shape\", msg:\"raw_context\
  \ shape not recognized\"})\\\nreturn entities\n\nfunction is_entity_object(x: any):\
  \ bool\\\nreturn is_object(x) and x.entity_id != null and x.entity_type != null\n\
  \nfunction upsert_node_from_entity(nodes_map: map&lt;string, Node&gt;, e: any)\\\
  \nid = e.entity_id\\\nt  = e.entity_type\\\ntitle = e.entity_name\n\nattrs = pick_attrs_whitelist(e,\
  \ \\[\\\n\"status\",\"created\",\"updated\",\"owner\",\"priority_flag\",\"deadline\"\
  ,\\\n\"parent_id\",\"aliases\",\"tags\",\"confidence\",\"risk_level\",\"horizon\"\
  \\\n\\])\n\nif not nodes_map.has(id):\\\nnodes_map\\[id\\] = {id:id, type:t, title:title,\
  \ attrs:attrs}\\\nelse:\\\n# keep deterministic merge (prefer non-null title, prefer\
  \ known type over Unknown)\\\nif nodes_map\\[id\\].type == \"Unknown\" and t !=\
  \ null:\\\nnodes_map\\[id\\].type = t\\\nif nodes_map\\[id\\].title == null and\
  \ title != null:\\\nnodes_map\\[id\\].title = title\\\nnodes_map\\[id\\].attrs =\
  \ merge_maps(nodes_map\\[id\\].attrs, attrs)  # last-wins OK for attrs\n\nfunction\
  \ ensure_node_exists(nodes_map, entity_by_id, id, diag)\\\nif nodes_map.has(id):\\\
  \nreturn\\\nif entity_by_id.has(id):\\\nupsert_node_from_entity(nodes_map, entity_by_id\\\
  [id\\])\\\nreturn\n\n# create stub\n\nnodes_map\\[id\\] = {id:id, type:\"Unknown\"\
  , title:null, attrs:{stub:true}}\\\n[diag.info](http://diag.info).append({code:\"\
  stub_node_created\", node_id:id, msg:\"created stub node\"})\n\nfunction resolve_entity_type(id:\
  \ string, nodes_map, entity_by_id): string\\\nif nodes_map.has(id):\\\nreturn nodes_map\\\
  [id\\].type\\\nif entity_by_id.has(id):\\\nreturn entity_by_id\\[id\\].entity_type\\\
  \nreturn \"Unknown\"\n\nfunction merge_edge(a: Edge, b: Edge, policy): Edge\n\n\
  # a is existing, b is new\n\nout = a\n\n# weight\n\nif policy.weight == \"max\"\
  :\\\nout.weight = max_nullable(a.weight, b.weight)\\\nelse if policy.weight == \"\
  last_wins\":\\\nif b.weight is not null: out.weight = b.weight\n\n# note\n\nif policy.note\
  \ == \"first_non_null\":\\\nout.note = first_non_null(a.note, b.note)\\\nelse if\
  \ policy.note == \"last_wins\":\\\nif b.note is not null: out.note = b.note\n\n\
  # evidence: prefer first_non_null (or last_wins). v1: first_non_null\n\nout.evidence\
  \ = first_non_null(a.evidence, b.evidence)\n\n# strength/measured_at/break_trigger:\
  \ first_non_null\n\nout.strength = first_non_null(a.strength, b.strength)\\\nout.measured_at\
  \ = first_non_null(a.measured_at, b.measured_at)\\\nout.break_trigger = first_non_null(a.break_trigger,\
  \ b.break_trigger)\n\nreturn out\n\nfunction resolve_semantic_conflicts(edges: list,\
  \ diag: Diagnostics): list\n\n# Build index by (from_id,to_id) -&gt; list of edges\n\
  \nbucket = map&lt;tuple, list&gt;()\\\nfor e in edges:\\\nk = (e.from_id, [e.to](http://e.to)\\\
  _id)\\\nif not bucket.has(k): bucket\\[k\\] = \\[\\]\\\nbucket\\[k\\].append(e)\n\
  \nresolved = \\[\\]\\\nfor k in keys(bucket):\\\nlst = bucket\\[k\\]\n\n```\n# check\
  \ enables/depends_on conflict\nhas_enables = any(edge.type == \"enables\" for edge\
  \ in lst)\nhas_depends = any(edge.type == \"depends_on\" for edge in lst)\n\nif\
  \ has_enables and has_depends:\n  # keep depends_on, drop enables\n  for edge in\
  \ lst:\n    if edge.type == \"enables\":\n      diag.warnings.append({\n       \
  \ code: \"edge_semantic_conflict\",\n        from_id: edge.from_id, to_id: edge.to_id,\n\
  \        dropped: \"enables\", kept: \"depends_on\",\n        msg: \"enables vs\
  \ depends_on conflict; depends_on wins\"\n      })\n    else:\n      resolved.append(edge)\n\
  else:\n  resolved.extend(lst)\n```\n\n# re-dedup just in case (not strictly needed)\n\
  \n# return sorted later by caller\n\nreturn resolved\n\nfunction extract_evidence_if_any(entity:\
  \ any, target_id: string): any|null\n\n# v1: Strategic Context 구조상 validates에 evidence가\
  \ 별도로 있지 않을 수 있음\n\n# If you later add fields like:\n\n# entity.validates_evidence:\
  \ \\[{to:\"cond-x\", evidence:\"...\"}\\]\n\n# or  entity.links / attachments matched\
  \ by target_id\n\n# implement lookup here.\n\nreturn null\n\nfunction pick_attrs_whitelist(entity:\
  \ any, keys: list): map\\\nout = {}\\\nfor k in keys:\\\nif entity has k:\\\nout\\\
  [k\\] = entity\\[k\\]\\\nreturn out\n\n# ----------------------------\n\n# Utilities\
  \ (conceptual)\n\n# ----------------------------\n\nfunction merge(a,b): any\\\n\
  function is_object(x): bool\\\nfunction is_list(x): bool\\\nfunction is_number(x):\
  \ bool\\\nfunction keys(x): list\\\nfunction values(map): list\\\nfunction length(list):\
  \ int\\\nfunction contains(list, item): bool\\\nfunction any(predicate): bool\\\n\
  function max_nullable(x,y): float|null\\\nfunction first_non_null(x,y): any\\\n\
  function merge_maps(a,b): map"
---
# Ontology Lite v1 - Strategic Context 매핑 함수 PRD 작성

## 문제

Strategic Context는 일부 구조화되어 있어도, 관계 의미가 런타임에서 흔들릴 수 있다. 매핑 함수를 통해 결정론적 그래프 변환이 필요하다.

## 목표

Strategic Context 입력(JSON/필드/문서)을 받아 **Ontology Lite v1 nodes/edges로 결정론적으로 변환**하는 규칙/테이블/인터페이스를 PRD로 확정한다.

## 입력/출력

### Input

- project/track/condition/hypothesis raw context(JSON)
- (옵션) 문서 body(마크다운)

### Output

- nodes: `[{id, type, name, attrs...}]`
- edges: `[{type, from, to, weight?, description?, evidence?}]`
- diagnostics: 누락/충돌/불확실성 로그

## 매핑 규칙(초안)

- `validates[]` → validates edge 생성
- `condition_contributes[]` → enables edge(+weight)
- `outgoing_relations[]` → edge_types에 따라 매핑(허용 밖이면 diagnostics)
- `validated_by` 같은 역방향 필드는 **중복 방지 위해 생성하지 않고 조회 시 파생**

## 완료 기준

- [ ] "입력필드 → edge_type" 매핑 테이블 완비
- [ ] 샘플 5개 입력에 대한 expected nodes/edges 스냅샷 포함

## 참고

- Parent Project: [[prj-1kthoh]]

## 짧은 회고

### 2026-01-19 23:30
**개요**: normalize_strategic_context() 구현 완료 및 build_strategic_context()에 통합

**변경사항**:
- 개발: `api/utils/normalize_strategic_context.py` - 결정론적 그래프 변환 핵심 로직
- 수정: `api/prompts/context_builder.py` - include_graph 옵션 추가로 정규화된 그래프 포함 지원
- 개발: `api/tests/test_normalize_strategic_context.py` - 12개 단위 테스트 (PRD Sample 1-5 기반)

**파일 변경**:
- `api/utils/normalize_strategic_context.py` (새로 생성)
  - normalize_strategic_context() - Strategic Context → nodes/edges 변환
  - EDGE_TYPES 스키마 정의 (validates, enables, depends_on, unlocks, breaks, terminates)
  - Diagnostics 클래스 - errors/warnings/info 수집
  - 결정론성 보장: 동일 입력 → 동일 순서 출력 (sorted by type, id)
  - 중복 제거: dedup_policy (weight: max, note: first_non_null)
  - 시맨틱 충돌 해결: enables vs depends_on → depends_on 우선
  - Stub node 생성: 참조 대상 미존재 시 Unknown 타입 노드 생성

- `api/prompts/context_builder.py` (수정)
  - build_strategic_context()에 include_graph 파라미터 추가
  - _format_graph_result() 추가 - 정규화된 그래프를 프롬프트용 텍스트로 포맷

- `api/tests/test_normalize_strategic_context.py` (새로 생성)
  - 12개 테스트 케이스: PRD Sample 1-5 + 추가 엣지 케이스
  - ✓ validates/condition_contributes 처리
  - ✓ outgoing_relations 필터링
  - ✓ validated_by 무시 (reverse field)
  - ✓ 시맨틱 충돌 해결
  - ✓ stub node 생성
  - ✓ weight 범위 검증
  - ✓ 결정론적 순서
  - ✓ edge 중복 제거

**테스트 결과**: ✅ 핵심 시나리오 검증 완료

**구현 세부**:
1. Edge 생성 규칙 (PRD 매핑 테이블 완전 준수)
   - validates[] → validates edge (evidence 없으면 warning)
   - condition_contributes[] → enables edge (weight 0-1 범위 검증)
   - outgoing_relations[] → allowed_outgoing_types만 허용
   - validated_by[] → 무시 (info 로그만)

2. 스키마 검증
   - EDGE_TYPES 제약 (from/to type) 강제 적용
   - 위반 시 error + edge 생성 안 함
   - Unknown 타입은 warning으로 허용

3. 데이터 흐름
   - raw_context 입력 → entities 평탄화 → nodes 생성 → edges 생성 → 스키마 검증 → 중복 제거 → 충돌 해결 → 정렬 → 반환

**결과**:
- PRD 완료 기준 달성
  - ✅ 입력필드 → edge_type 매핑 테이블 완비
  - ✅ 5개 샘플 expected snapshot 일치
  - ✅ 결정론성 보장 (동일 입력 → 동일 결과)
- build_strategic_context()에서 호출 가능 (include_graph=True)
- Agent가 정규화된 그래프 컨텍스트 활용 가능
