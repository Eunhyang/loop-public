---
entity_type: Task
entity_id: tsk-002-13
entity_name: Promotion - 2단계 트랜잭션 리팩토링
created: '2026-01-09'
updated: '2026-01-19'
status: done
project_id: prj-002
parent_id: prj-002
assignee: 김은향
priority: high
start_date: '2026-01-09'
due: '2026-01-09'
aliases:
- tsk-002-13
tags: []
type: dev
notes: '# Promotion - 2단계 트랜잭션 리팩토링


  ## Description


  프로모션 코드 redemption 시스템의 아키텍처 개선 - 2단계 트랜잭션 패턴 적용 (Reserve → RC 호출 → Finalize) -
  레이스 컨디션 해결 - RevenueCat 중복 호출 방지 - 데이터 구조 개선 (promotion_codes/{code}/redemptions/{userId})


  ## Notes


  (PRD will be added here)


  ## References


  - Plan: /Users/gim-eunhyang/.claude/plans/deep-booping-pie.md'
target_project: loop-api
---
# Promotion - 2단계 트랜잭션 리팩토링

## Description

프로모션 코드 redemption 시스템의 아키텍처 개선
- 2단계 트랜잭션 패턴 적용 (Reserve → RC 호출 → Finalize)
- 레이스 컨디션 해결
- RevenueCat 중복 호출 방지
- 데이터 구조 개선 (promotion_codes/{code}/redemptions/{userId})

## Notes

### Tech Spec

#### 현재 문제점
1. **레이스 컨디션 (Critical)**: `usedBy.includes()`, `currentUses >= maxUses` 체크가 트랜잭션 밖에서 수행 → 동시 요청 시 중복 사용 가능
2. **Idempotency 없음 (Critical)**: `promotion_redemptions.doc()` auto ID 사용 → 같은 요청 2번 시 원장에 2줄 기록
3. **RevenueCat 중복 호출 위험 (Critical)**: RC 호출이 트랜잭션 밖 → 더블탭/재시도 시 RC 2번 호출 위험
4. **데이터 중복 + 확장성 문제 (Medium)**: `usageDetails` Map, `usedBy[]` 배열이 커지면 1MB 문서 제한 위험

#### 리팩토링 전략: 2단계 트랜잭션 + 단계적 폐기
- **SoT (Source of Truth)**: `promotion_codes/{code}/redemptions/{userId}`
- **2단계 패턴**: Reserve(pending) → RC 호출 → Finalize(success/failed)
- **레거시**: `usageDetails`, `usedBy` → 더 이상 쓰기 안 함, 읽기 폴백만

#### 새로운 플로우 다이어그램
```
┌─────────────────────────────────────────────────────────────────┐
│  Client Request                                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Tx#1: Reserve (pending)                                        │
│  ─────────────────────────────────────────────────────────────  │
│  1. transaction.get(promoDoc)                                   │
│  2. transaction.get(redemptionRef)                              │
│     - status=success → "이미 사용" 반환                         │
│     - status=pending → "처리 중" 반환 (중복 요청 차단)          │
│  3. maxUses 체크                                                │
│  4. v1 폴백: usageDetails[userId] 존재 여부 체크                │
│  5. transaction.set(redemptionRef, { status:'pending', ... })   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  RevenueCat API 호출 (트랜잭션 밖)                              │
│  - pending 상태이므로 중복 요청은 여기까지 못 옴               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Tx#2: Finalize (success/failed)                                │
│  ─────────────────────────────────────────────────────────────  │
│  RC 성공 시: redemption.status='success', currentUses++         │
│  RC 실패 시: redemption.status='failed', error 기록             │
└─────────────────────────────────────────────────────────────────┘
```

#### 데이터 구조 변경 (Before/After)

**Before (v1)**
```
promotion_codes/
  {code}/
    maxUses, currentUses, validFrom, validUntil, ...
    usageDetails: { [userId]: { ... } }  ← 레거시
    usedBy: [...]                         ← 레거시

promotion_redemptions/
  {autoId}/  ← 삭제 예정
```

**After (v2)**
```
promotion_codes/
  {code}/
    maxUses, currentUses, validFrom, validUntil, lastUsedAt, ...
    (usageDetails, usedBy는 마이그레이션 후 삭제)

    redemptions/  ← 하위 컬렉션 (SoT)
      {userId}/  ← idempotent!
        status: "pending" | "success" | "failed"
        code, userId, durationMonths, deviceId
        expiresAt: Timestamp
        grantedAt: Timestamp
        rc_payload, rc_success
        createdAt, failedAt?, error?
```

#### 수정 파일 목록
| 파일 | 변경 내용 |
|------|----------|
| `functions/src/promotions.ts` | 2단계 트랜잭션 패턴, 원장 경로 변경, 읽기 폴백 |
| (새 파일) `scripts/migrate-redemptions.js` | 마이그레이션 스크립트 |

### Todo
- [x] Step 1: promotions.ts - Tx#1 Reserve (pending 상태 생성)
- [x] Step 2: promotions.ts - RevenueCat API 호출 로직 수정
- [x] Step 3: promotions.ts - Tx#2 Finalize (success/failed)
- [x] Step 4: checkPromoCode - 읽기 로직 v2 우선, v1 폴백
- [ ] Step 5: Firebase 에뮬레이터 테스트
- [ ] Step 6: 배포
- [ ] Step 7: 마이그레이션 스크립트 작성 및 실행

### Implementation Summary (2026-01-09)

**Files Modified:**
- `functions/src/promotions.ts` - 2단계 트랜잭션 패턴 구현 완료

**What Changed:**

1. **Tx#1 Reserve (lines 93-162)**
   - Check redemption exists (success/pending/failed)
   - TTL check for pending (5분)
   - v1 fallback check (usageDetails[userId])
   - Pre-RC capacity check (currentUses < maxUses)
   - Create pending redemption

2. **RevenueCat API Call (lines 164-192)**
   - Outside transaction
   - Protected by pending state from Tx#1

3. **Tx#2 Finalize (lines 194-281)**
   - Verify redemption is pending (finalize gating)
   - Re-check capacity (TOCTOU defense)
   - On capacity exceeded: mark failed + return (NO throw!)
   - On success: update redemption, increment currentUses, update user.premium
   - On RC failed: mark redemption failed

4. **checkPromoCode Updated (lines 473-532)**
   - Check v2 (redemptions subcollection) first
   - Handle pending status correctly ("프로모션 처리 중")
   - Fallback to v1 (usageDetails[userId])

**Known Limitations (documented):**
- Small TOCTOU window for concurrent different users near capacity
  - pending count check 생략 (성능상)
  - RC idempotency key 미지원 (API 제약)
- Acceptable trade-off: 같은 유저 중복 차단은 완벽, 다른 유저 동시 요청은 극소수 케이스에서만 overselling 가능

**Code Review:**
- ✅ Codex validation passed (2 rounds)
- ✅ TypeScript compilation successful
- ✅ Critical bugs fixed (transaction abort, capacity check)

### References
- Plan: /Users/gim-eunhyang/.claude/plans/deep-booping-pie.md
- Branch: tsk-002-13 (merged from tsk-002-02)
